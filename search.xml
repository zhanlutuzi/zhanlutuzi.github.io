<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>虚拟机安装MacOS一些问题的解决</title>
      <link href="/2022/06/09/macos-vmware-question-solve/"/>
      <url>/2022/06/09/macos-vmware-question-solve/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>太久不更新了，<del>果然人类的本质就是鸽子吗</del></p><p>今天结束了数据库的上机，晚上不想写报告，开始折腾起来虚拟机了；起因是我之前写了篇虚拟机安装MacOS的文章👉<a href="https://zhanlutuzi.top/2022/02/13/hexo-bo-ke-da-jian/#toc-heading-16">链接</a>；但是安装上之后屏幕显示分辨率一直不正常，而且也没办法用代理链接Github，这就非常的没用了。今天折腾了一下，把问题解决了，写篇博客记录一下🖖</p><p>​                                                                                                                                            ——某位马上要考六级期末一堆DDL的<del>摸鱼</del>大学生</p><h1 id="虚拟机代理配置"><a href="#虚拟机代理配置" class="headerlink" title="虚拟机代理配置"></a>虚拟机代理配置</h1><p>一般来说，在虚拟机内部设置代理有这么几个办法：</p><ul><li>像你用Windows一样在虚拟机内部装代理软件<ul><li>不推荐，别用</li></ul></li><li>借助VMware，共享主机的代理<ul><li>优雅！ Gorgeous💃</li></ul></li></ul><p>那么我就介绍第二种办法，<del>要优雅XD</del></p><h2 id="VMWare配置网络环境"><a href="#VMWare配置网络环境" class="headerlink" title="VMWare配置网络环境"></a>VMWare配置网络环境</h2><p>打开虚拟网络编辑器</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609234728971.png" alt="打开虚拟网络编辑器"></p><p>点击更改设置</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609234932710.png"></p><p>如图所示加上VMnet8，并配置相关参数。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609235050872.png" alt="其实这里加别的VMnet也行，配置一样就可以"></p><p>接下来就对单独的虚拟机进行设置</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609235236761.png" alt="打开设置页面"></p><p>更改网络设置</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609235335474.png" alt="网络链接改成VMnet8"></p><p>到这里，只需要再获取VMnet8的ip地址就好；打开CMD，输入<code>ipconfig</code>找到VMnet8</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609235513899.png" alt="务必记住它，后面有用"></p><h2 id="虚拟机内部设置"><a href="#虚拟机内部设置" class="headerlink" title="虚拟机内部设置"></a>虚拟机内部设置</h2><p>打开你的虚拟机，这里用MacOS做演示；Ubuntu操作见<a href="https://www.jianshu.com/p/6c7abd4adc9b">链接</a></p><p>进入你的Mac虚拟机，打开设置里的网络选项，点击高级进入下图页面；请将我勾选的四项都设置为上面让你记住的ip地址<img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220609235829077.png"></p><p>端口号和你的代理软件相关，我这里使用的是Clash，端口就是上面那个箭头所指的位置；记得一定把<code>Allow LAN</code>打开，因为VMnet8走的就是LAN(Local Area Network)</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220610000058927.png"></p><p>以上，代理设置完毕！愉快地使用 Github 吧！</p><h1 id="MacOS分辨率显示异常"><a href="#MacOS分辨率显示异常" class="headerlink" title="MacOS分辨率显示异常"></a>MacOS分辨率显示异常</h1><p>在你按照我之前的教程安装完MacOS后一定会发现，这个分辨率怎么这么糊啊，而且还改不了，就很难受🤦‍♂️</p><p>下面我们着手解决这个问题</p><h2 id="安装VMwareTool"><a href="#安装VMwareTool" class="headerlink" title="安装VMwareTool"></a>安装VMwareTool</h2><p>打开MacOS后，点击菜单栏里的<code>虚拟机</code>再点击<code>安装VMware Tool</code>，按照提示进行安装就行，详情请看👉<a href="https://www.geekrar.com/how-to-fix-macos-catalina-screen-resolution-on-vmware/">链接</a></p><p>具体步骤</p><ol><li>安装VMwareTool</li><li>提示需要权限，按照指引给权限</li><li>重启</li><li>再次安装</li><li>再重启</li><li>安装完毕</li></ol><h2 id="修改VMware设置"><a href="#修改VMware设置" class="headerlink" title="修改VMware设置"></a>修改VMware设置</h2><p>打开首选项</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220610001618493.png"></p><p>如图进行设置</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220610001707275.png"></p><p>设置完后重启MacOS</p><p>点一下自由拉伸，然后随便拉伸一下虚拟机的窗口</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220610002009689.png"></p><p>如果这样还没有用，就打开<code>Terminal</code></p><p>输入<code>/Library/Application\Support/VMware\ Tools/vmware-resolutionSet 1920 1080</code></p><p>之后再在设置里改一下显示比例</p><p>这个方法我没有使用，如果有问题可以参考👉<a href="https://www.zhihu.com/question/68703160">链接</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/68703160">https://www.zhihu.com/question/68703160</a></p><p><a href="https://blog.51cto.com/sddai/3090254">https://blog.51cto.com/sddai/3090254</a></p><p><a href="https://www.jianshu.com/p/4384047334d1">https://www.jianshu.com/p/4384047334d1</a></p><p><a href="https://www.geekrar.com/how-to-fix-macos-catalina-screen-resolution-on-vmware/">https://www.geekrar.com/how-to-fix-macos-catalina-screen-resolution-on-vmware/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> VMware </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记_03</title>
      <link href="/2022/04/04/os-3-i-o/"/>
      <url>/2022/04/04/os-3-i-o/</url>
      
        <content type="html"><![CDATA[<h1 id="I-x2F-O-硬件原理"><a href="#I-x2F-O-硬件原理" class="headerlink" title="I/O 硬件原理"></a>I/O 硬件原理</h1><h2 id="I-x2F-O-设备"><a href="#I-x2F-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h2><p>I/O 设备可以分为：</p><ul><li>块设备<code>Block Device</code><ul><li>设备将信息存储在固定大小的块中<code>如磁盘</code></li><li>数据块大小一般为<code>512 Bytes--&gt;32768 Bytes</code></li><li>每个块都能独立于其它块而读写</li></ul></li><li>字符设备<code>Character Device</code><ul><li>设备发送或接收字符流</li><li>无法编址，也就不存在寻址操作</li><li>如<code>打印机、键盘、网络接口、鼠标等</code></li></ul></li><li>其他<ul><li>无法被分到块设备或字符设备中</li><li>比如<code>时钟</code></li></ul></li></ul><blockquote><p>❗ I/O 设备在速度上差异很大，见下图，这为我们管理 I/O 设备提出了挑战，在后文中会提到解决办法。</p></blockquote><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404160027122.png" style="zoom:50%;"><h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>​    <strong>I/O设备组成中的电子部件</strong>被称为设备控制器，操作系统往往和设备的控制器打交道，大多数个人计算机采用<code>总线模型</code>进行 CPU 与控制器之间的交流。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/ApplicationFrameHost_1vQQ1KaZ7j.png"></p><p>​    大型机则采用其他模型，此类模型带有<code>I/O通道</code>，一种专用于输入输出工作的计算机。</p><h2 id="内存映射I-x2F-O"><a href="#内存映射I-x2F-O" class="headerlink" title="内存映射I/O"></a>内存映射I/O</h2><blockquote><p>❓ CPU如何控制寄存器与设备数据缓冲区进行通信？</p></blockquote><ul><li>使用I/O端口<ul><li>内存和I/O地址空间不同</li></ul></li><li>内存映射I/O<ul><li>I/O寄存器是内存空间的一部分</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404193104304.png"></p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>大部分I/O接口提供一个输出用于驱动<code>IRQ Interrupt ReQuest</code>线</p><p>即插即用技术使得 BIOS 在启动时为设备自动分配 IRQ 以避免冲突</p><h2 id="直接存储器存取-DMA"><a href="#直接存储器存取-DMA" class="headerlink" title="直接存储器存取 DMA"></a>直接存储器存取 DMA</h2><p><code>Direct Memory Access , DMA</code></p><p>它使得毋须占用CPU宝贵的时间去交换数据，利用 DMA 控制器调控多个设备的数据传送</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404193751362.png"></p><h1 id="I-x2F-O-软件原理"><a href="#I-x2F-O-软件原理" class="headerlink" title="I/O 软件原理"></a>I/O 软件原理</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><p>设备无关性</p><ul><li>访问I/O毋须指定设备</li></ul></li><li><p>统一命名法</p></li><li><p>错误处理</p></li><li><p>同步/异步传输</p></li><li><p>缓冲</p></li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404200109964.png"></p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><p>用来控制特定设备的一组特定的代码被称作设备驱动程序，驱动程序传统上是系统内核的一部分</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404201218694.png"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>可抢占资源<ul><li>抢占以后没有副作用，如存储器</li></ul></li><li>不可抢占资源<ul><li>抢占后危害很大，比如CD刻录机</li><li>死锁与不可抢占资源相关</li></ul></li></ul><h3 id="使用一个资源的顺序"><a href="#使用一个资源的顺序" class="headerlink" title="使用一个资源的顺序"></a>使用一个资源的顺序</h3><ol><li>请求资源</li><li>使用资源</li><li>释放资源</li></ol><h2 id="死锁的原理"><a href="#死锁的原理" class="headerlink" title="死锁的原理"></a>死锁的原理</h2><blockquote><p>一个进程集合中的每个进程都在等待本集合中其他进程才能引发的事件，那么这组进程是死锁的</p></blockquote><h3 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h3><ul><li>互斥条件<ul><li>一个资源，要么被分配给一个进程，要么就是可用的</li></ul></li><li>占有和等待条件<ul><li>已分配到资源的进程可以请求新的资源</li></ul></li><li>不可抢占条件<ul><li>被分配的资源不能抢占</li></ul></li><li>环路等待条件<ul><li>环路中每个进程都在等待下一个进程占用的资源</li></ul></li></ul><h3 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404202545162.png"></p><h3 id="处理死锁的四个策略"><a href="#处理死锁的四个策略" class="headerlink" title="处理死锁的四个策略"></a>处理死锁的四个策略</h3><ul><li>忽略该问题<ul><li>鸵鸟算法</li></ul></li><li>检测死锁并恢复</li><li>谨慎地对资源进行动态分配</li><li>破坏上述四个必要条件之一</li></ul><h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><ul><li>破坏互斥使用条件</li><li>禁止已拥有资源的进程等待其他资源</li><li>给所有资源提供一个全局编号，请求需要按编号顺序提出</li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404204123554.png"></p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p><strong><font color="red" size="4.5" face="仿宋">通过仔细分配资源来避免死锁</font></strong></p><h3 id="单一资源的银行家算法"><a href="#单一资源的银行家算法" class="headerlink" title="单一资源的银行家算法"></a>单一资源的银行家算法</h3><p>在进程申请资源的时候，判断本次申请是否安全，如果安全再分配，就像银行借贷款。</p><h3 id="资源轨迹"><a href="#资源轨迹" class="headerlink" title="资源轨迹"></a>资源轨迹</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404205750270.png"></p><p>上图中，阴影区域内就是资源发生冲突的区域</p><h3 id="多种资源的银行家算法"><a href="#多种资源的银行家算法" class="headerlink" title="多种资源的银行家算法"></a>多种资源的银行家算法</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220404210239120.png"></p><ul><li>E 总资源</li><li>P 已分配资源</li><li>A 剩余资源</li></ul><p>算法详情：</p><ol><li>查找右边矩阵中是否有一行，其未被满足的资源数均小于等于A。如果不存在这样的行，系统将死锁，因为任何进程都无法运行结束。</li><li>若找到这样一行，则可以假设它获得所需的资源并运行结束，将该进程标为结束，并将资源加到向量 A 上。</li><li>重复以上两步，直到所有的进程都标记为结束。若能达到这种状态，则初始状态是安全的；或者直到发生死锁。</li></ol><blockquote><p>📌事实上，银行家算法虽然很有意义，但缺乏实用价值，因为很少有进程能在运行前知道自己所需资源的最大值！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-4 MemoryManage</title>
      <link href="/2022/04/04/os-4-memorymanage/"/>
      <url>/2022/04/04/os-4-memorymanage/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>最佳的存储器当然是容量无限大、速度无限快；但由于经济和技术原因，现实中通常把存储器分为四类：</p><ol><li><code>CPU</code>内部寄存器<ul><li>访问速度最快、容量小、昂贵</li></ul></li><li>高速缓存<code>Cache</code></li><li>内存<ul><li>速度适中、价格适中</li></ul></li><li>磁盘<ul><li>容量大、断电数据仍然保存，非易失型</li></ul></li></ol><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220513221926760.png"></p><h2 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h2><ul><li>记录存储器的使用情况</li><li>存储空间的分配与回收</li><li>内存上保存不下的进程数据转移至磁盘上保存</li></ul><h1 id="2-基本的存储管理"><a href="#2-基本的存储管理" class="headerlink" title="2.基本的存储管理"></a>2.基本的存储管理</h1><p>存储管理系统分为两类：</p><ol><li>需要在磁盘和内存间把进程换进换出</li><li>不需要换进换出</li></ol><p>上面的换进换出都是因为<font color="red">内存不足</font>而引起的。</p><h2 id="2-1-单道程序存储管理"><a href="#2-1-单道程序存储管理" class="headerlink" title="2.1 单道程序存储管理"></a>2.1 单道程序存储管理</h2><p>​        把整个内存划分为用户区和系统区，用户区一次只能装入一个进程。</p><p>下图中</p><ul><li>（a）用于早期大小型机</li><li>（b）用于掌上电脑、嵌入式系统</li><li>（c）用于早期PC 如MS-DOS</li><li>存放在内存高端的ROM中的系统内容，称为基本输入输出系统<code>Basic Input and Output System,BIOS</code></li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220513223826416.png"></p><p>这种方式一次只能运行一个进程，若要运行新的进程就把旧的进程覆盖掉。</p><h2 id="2-2-固定分区的多道程序系统"><a href="#2-2-固定分区的多道程序系统" class="headerlink" title="2.2 固定分区的多道程序系统"></a>2.2 固定分区的多道程序系统</h2><p>对于多进程的系统，一个进程由于I/O被阻塞时，另一个进程可以去使用CPU，增加了CPU的利用率。</p><p>为了实现多道程序技术，将内存划分为n个分区，各分区的大小可以相等可以不等。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220513225505899.png"></p><p>​        上图中a有缺陷，可能小分区队列是满的，大分区确是空的，造成浪费。为了改变这种情况就使用了b中的方案，使用单一的输入队列；有分区空闲时，找到能装入该分区的最大进程，减少浪费空间。但这样小进程被歧视，不易被分配到空间。</p><p>解决方法</p><ul><li>始终保留至少一个小分区</li><li>规定一个进程被忽略的次数不能超过k次</li></ul><p>​    上面讲到的方法被称为固定数量任务的多道程序<code>Multiprogramming with a Fixed number of Tasks,MFT</code>操作员早晨开机时人为划分出多个分区，在IBM早期的大型机OS/360上使用了多年。<font color="red">现在很少有人会使用这种方法。</font></p><h2 id="2-3-重定位和存储保护"><a href="#2-3-重定位和存储保护" class="headerlink" title="2.3 重定位和存储保护"></a>2.3 重定位和存储保护</h2><p>不同的作业在不同的分区运行，当一个程序被链接的时候，链接器必须知道程序将在内存的什么地方运行。</p><p>内存保护，不同分区不能彼此干扰</p><p>一种解决方案</p><ul><li>加入基地址寄存器和边界寄存器</li></ul><p><font color="red">现在没有人会使用这种方法。</font></p><h1 id="3-交换技术"><a href="#3-交换技术" class="headerlink" title="3.交换技术"></a>3.交换技术</h1><h1 id="4-虚拟存储管理"><a href="#4-虚拟存储管理" class="headerlink" title="4.虚拟存储管理"></a>4.虚拟存储管理</h1><h1 id="5-页面置换算法"><a href="#5-页面置换算法" class="headerlink" title="5.页面置换算法"></a>5.页面置换算法</h1><h1 id="6-页式存储管理中的设计问题"><a href="#6-页式存储管理中的设计问题" class="headerlink" title="6.页式存储管理中的设计问题"></a>6.页式存储管理中的设计问题</h1><h1 id="7-段式存储管理"><a href="#7-段式存储管理" class="headerlink" title="7.段式存储管理"></a>7.段式存储管理</h1>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机三级备考指南</title>
      <link href="/2022/03/28/ncre-3-tutorial/"/>
      <url>/2022/03/28/ncre-3-tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><pre class="line-numbers language-none"><code class="language-none">本文为转载整理，一切著作权归原作者所有！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来源：</p><blockquote><p><a href="https://96ea5f9a.wiz06.com/wapp/pages/view/share/s/2mWB-q0kLQ9B2ZqZt31C4U2z0nE7Tm03PAoR28IbN93qLZvQ">三级网络技术考过指南|为知笔记</a></p><p><a href="https://www.bilibili.com/medialist/play/watchlater/BV1F5411a76A">视频|这些技巧助你通过三级网络技术</a></p></blockquote><hr><h1 id="三级网络技术考过指南"><a href="#三级网络技术考过指南" class="headerlink" title="三级网络技术考过指南"></a>三级网络技术考过指南</h1><h2 id="前言（必读）"><a href="#前言（必读）" class="headerlink" title="前言（必读）"></a>前言（必读）</h2><hr><p><strong>本文档总大小 5MB 左右，请注意流量</strong><br><strong>若手机端浏览不便，请尝试使用电脑浏览器</strong></p><p>这份指南写于我备考三级一周后，因为做了几套题之后感觉这个考试的知识点和题型很固定，而将这些知识点和做法概括总结出来可以帮助以后考试的同学。</p><p>对于没有相应基础的绝大多数同学，如果想考过三级网络技术，首先要克服见到陌生复杂题目的恐惧感。话说回来，其实这些题没有哪一道是真正需要动脑进行复杂思考的，只是知识点没见过，做题的方法不清楚，一旦知道了就能写对。这个考试没有什么含金量，一周的练习基本上足够了。</p><p>我们专业去年上了计算机网络这门课，但跟这个考试的关系不大，只有少量的考点学过。所以我对题目的解析是很业余的，但这也是个好处，正是因为不专业写的就比较直白，适合没有基础的同学参考。</p><p>另外，需要强调一下，本文档以应试为目的指在帮助你通过考试，而非掌握计算机网络技术。</p><p>如果发现有错误或者有其他建议请与我联系，多谢。</p><p>我的邮箱：<a href="mailto:increasesong@foxmail.com">increasesong@foxmail.com</a></p><p><strong>转载请注明笔记原链接</strong><br><strong>欢迎把笔记链接分享给有需要的同学</strong></p><p><strong>后增：为什么考三级？</strong><br>既然二级都过了，再考个三级呗，有的学校可能还有实践学分。别人二级office的很多，你三级看上去就显得厉害一点。</p><p><strong>【重要更新】</strong><br>自2018年3月份全国计算机等级考试（第51次）起，取消了三级获证的前置条件。<strong>直接报名考三级就可以了，不再需要对应的二级科目通过。</strong></p><p><strong>为什么三级选网络技术这科？</strong><br>因为我考的时候，查了查发现考这个的最多，考的人越多的科目考试题就可能越标准规范，我对其他的科目也没有特别有兴趣的，所以就考这个了。所以我也只能写网络技术，所以你们选网络技术备考也就最方便。</p><p><strong>要不要考四级？</strong><br>从用我的角度来讲，这个考试本来就没什么含金量，我没有考。还想考计算机方面的证，可以去考软考[计算机技术与软件专业技术资格（水平）考试]。如果考研想考计算机，可以去了解CCF CSP考试，对一些学校复试上机可能有用。<br>听说计算机等级考试四级比三级还简单，也是买题做题就行了。</p><hr><h2 id="1-基础准备"><a href="#1-基础准备" class="headerlink" title="1.基础准备"></a>1.基础准备</h2><h3 id="1-1-题库"><a href="#1-1-题库" class="headerlink" title="1.1 题库"></a>1.1 题库</h3><p>买一本三级网络技术题库或者是题库软件（20 元左右），不需要买更多，总之有成套的题可以做就行。真题目前大概有二十套左右。</p><h3 id="1-2-二进制转换"><a href="#1-2-二进制转换" class="headerlink" title="1.2 二进制转换"></a>1.2 二进制转换</h3><p>应该学过</p><p>网络技术用到的一般是八位二进制数。也就是 0 ~ 255，即 0000 0000 ~ 1111 1111（每四位空一格便于观察）</p><p>我做题前在草稿纸上先这样画</p><p><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/8291765.png" alt="img"><br>这样，比如说我看见 1001 1000 这个数，就知道这是 128+16+8 对应的数。</p><p>反过来，十进制转换二进制也可以利用这个简图。还有一些规律，自己做题中摸索吧，你可能会找到更好的方法。</p><p>下面几组记忆一下，做题时会比较方便（不要畏难，做题见多了就记住了）</p><table><thead><tr><th>二进制</th><th>十进制</th></tr></thead><tbody><tr><td>1000 0000</td><td>128</td></tr><tr><td>1100 0000</td><td>192</td></tr><tr><td>1110 0000</td><td>224</td></tr><tr><td>1111 0000</td><td>240</td></tr><tr><td>1111 1111</td><td>255</td></tr></tbody></table><h3 id="1-3-基础概念"><a href="#1-3-基础概念" class="headerlink" title="1.3 基础概念"></a>1.3 基础概念</h3><p>如果是学过计算机网络相关知识的同学可以不看，下面是非专业的不标准的可能还有错的描述，仅仅是为了完全没有基础的同学有个粗略了解。</p><p>计算机网络是一些电脑相互链接组成的，这些电脑叫做<strong>主机</strong>，可能相距很远，也可能是一间屋子里的。</p><p>就像正常情况下两个人要用同一种语言交流一样。主机之间的联系也要按照相同的标准才行，这些标准叫做<strong>协议</strong>。因为主机之间的联系是一件复杂的事。所以有多种协议解决不同方面的问题，比如 TCP、BGP、DHCP 等等。</p><p>相距太远的主机之间不能直接联系，就需要一些设备，比如路由器、交换机等等，你只知道他们都是为了主机联系的中间转发设备就行。</p><p>还需要地址，因为没有地址就不知道主机在哪，这个标识主机的就是 IP 地址。<br>IP 地址是类似这样的：10000000.1110000.01000000.10110001，一共 <strong>32</strong> 位，为了人看起来方便就写成 128.224.64.177 这种点分十进制的形式。</p><p>还有一种叫做 MAC 地址，是标识硬件设备的地址。</p><p>主机还可以广播给整个网络，广播地址是 IP地址 32 位全置 1 的地址，即 255.255.255.255。</p><p>当你访问一个网站，你的电脑先将网址发送给 DNS 服务器（域名解析服务器），这个服务器能将你写的网址域名变成 IP 地址，这样你的电脑就知道想要访问的网页放在哪了。</p><p>上面这些并不能让你真正理解计算机网络（其实我也不是很清楚），主要是让你在见到陌生名词的时候别害怕，有些名词不理解也不会影响做题。</p><h3 id="1-4-备考建议"><a href="#1-4-备考建议" class="headerlink" title="1.4 备考建议"></a>1.4 备考建议</h3><p>这就是个人的方法了，也不一定适合你。</p><p>【1】首先对着一套三级题和答案看一遍，每道题都看答案解析是怎么说的。看答案不必弄懂（当然你要真的全弄懂也很厉害），知道怎么选出来就行，不明白跳过也行。同时也找找看看我笔记里写没写这道题的知识点。</p><p>这一遍是比较简略的，对题目有个简单的印象就够了。但这遍也是比较困难的，因为几乎都是陌生的东西。</p><p>【2】接下来，同时做两三套试题甚至更多套。按着笔记里的知识点做，看到哪个知识点就到这些套题里找，对照着做题来掌握这个知识点。如果笔记里没有提到或者没写详细的就看答案怎么说，实在不明白的还可以跳过。</p><p>这个阶段是需要比较认真的看了，我这个阶段是在写笔记中度过的。经过这个阶段你就能明白哪些知识点考察比较固定，一些题的固定做法是什么，对考试有比较完全的认识了。</p><p>【3】接下来，就把剩下的套题都做了，反正一共就二十套左右。怎么做都行，按套或者按题型什么的自己安排，反正做一遍。如果没时间了，至少把选择题做一遍。</p><p>这一遍就是完善熟练的阶段，还可能有一些我笔记里没写的知识点你也会了。</p><p>【补充】有的同学还是感觉难，那就先把第一道大题和最后一道大题的两个填表都仔细弄会了。这两个表就 20 分到手了。接下来学习可能会感觉踏实一点。</p><hr><h2 id="2-选择题（40-道-40-分）"><a href="#2-选择题（40-道-40-分）" class="headerlink" title="2.选择题（40 道 40 分）"></a>2.选择题（40 道 40 分）</h2><p>根据做题方法不同划为三类</p><ul><li>第一类：几乎每套题都考，掌握简单做法即可选出正确答案</li><li>第二类：每套题里有 5 道左右，看上去非常复杂的大段配置代码</li><li>第三类：从四个选项里选出一项正确或错误的，其中部分知识点是常考的，比较零散</li></ul><h3 id="2-1-第一类选择题"><a href="#2-1-第一类选择题" class="headerlink" title="2.1 第一类选择题"></a>2.1 第一类选择题</h3><h4 id="2-1-1-问传输速度"><a href="#2-1-1-问传输速度" class="headerlink" title="2.1.1 问传输速度"></a>2.1.1 问传输速度</h4><p>OC-3 对应 155.52 Mbps<br>OC-12 对应 622.08 Mbps<br>（显然，这是一道送分题）</p><h4 id="2-1-2-求交换机带宽"><a href="#2-1-2-求交换机带宽" class="headerlink" title="2.1.2 求交换机带宽"></a>2.1.2 求交换机带宽</h4><p>通常是求总带宽<br>例：某交换机有 12 个 10/100 Mbps 电端口和 2 个 1000 Mbps 光端口，所有端口都在全双工状态下，那么总带宽为（ ）<br>解：忽略 10/100 中的 10，当成 100 Mbps 就好。12 * 100 + 2 * 1000 = 3200，又因为<strong>全双工</strong>所以乘以 2 得 6400 Mbps ,即 6.4 Gbps</p><p>有时候求上联端口带宽<br>例：某交换机有 16个100/1000 Mbps 全双工下联端口，那么上联端口带宽至少为（ ）<br>解：16 * 1000 * 2 = 32000 Mbps = 32 Gbps，<strong>上联一般是下联的 1/20</strong> ，所以至少为 32 除以 20 得 1.6 Gbps</p><h4 id="2-1-3-系统可用性与停机时间"><a href="#2-1-3-系统可用性与停机时间" class="headerlink" title="2.1.3 系统可用性与停机时间"></a>2.1.3 系统可用性与停机时间</h4><table><thead><tr><th>可用性</th><th>停机时间</th></tr></thead><tbody><tr><td>99.9%</td><td>≤8.8小时</td></tr><tr><td>99.99%</td><td>≤53分钟</td></tr><tr><td>99.999%</td><td>≤5分钟</td></tr></tbody></table><p>也是送分题，但要记准确。比如 53 分钟，有时候会问 55 分钟的情况，要是记成 50 或者大约 1 小时就没法做了。</p><h4 id="2-1-4-写地址块的子网掩码"><a href="#2-1-4-写地址块的子网掩码" class="headerlink" title="2.1.4 写地址块的子网掩码"></a>2.1.4 写地址块的子网掩码</h4><p>例：IP 地址块 59.67.159.125/11 的子网掩码可写为（ ）<br>解：不用看 IP 地址，只看 <strong>/11</strong> 就够了。<br>11 代表子网掩码的前 11 位都是 1 ，所以可以写出子网掩码 11111111.11100000.00000000.00000000 转换为十进制即是 255.224.0.0<br>做题熟练后其实不用写上面那堆 1 和 0 就能选出正确答案。</p><h4 id="2-1-5-网络地址转换-NAT"><a href="#2-1-5-网络地址转换-NAT" class="headerlink" title="2.1.5 网络地址转换 NAT"></a>2.1.5 网络地址转换 NAT</h4><p><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/945125.png" alt="img"><br>会给你一个这样的图，问你 ① ② 是什么<br>只需要知道②和紧挨着它的 S 数字相同，所以②应该是 202.0.1.1,5001 ;同理，①是 10.0.0.1,3342。<br>还有时候会问某个小方框里的 S,D 分别是什么，看上面的图你会发现，上面两个方框和下面两个方框里的数字是对称的，做题时对称一下就写出答案了。</p><h4 id="2-1-6-IP-地址块聚合"><a href="#2-1-6-IP-地址块聚合" class="headerlink" title="2.1.6 IP 地址块聚合"></a>2.1.6 IP 地址块聚合</h4><p><strong>第一种：问聚合后的地址块</strong><br>下面演示三个地址的聚合<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/1584312.png" alt="img"><br>步骤为：转成二进制；对齐找前多少位是相同的；转回十进制写答案。<br>这样就得出聚合后的地址为：192.67.159.192/26<br>Tips：转换二进制时，因为前三段十进制本来就一样，所以可以只转换最后一段；<br>不要一个一个数有多少位相同的，因为前三段相同就知道有 3 * 8 = 24 位，再加上 2 就是 26。</p><p><strong>第二种：问聚合后可用 IP 数</strong><br><strong>下面两种情况的做法由网友 Yes 补充，十分感谢</strong>，之前我写的不当方法已删除。</p><p>【第一种情况】如未来教育上机考试第一套试题第10题：<br>“ IP 地址块 202.113.79.128/27、202.113.79.160/27 和 202.113.79.192/27 经过聚合后可用的地址数为___”</p><p>因为格式都是 xxx.xxx.xxx.xxx/27，本题中“/”后边的数字都是相同的。<br>所以遇到这种题，先把前两个 IP 聚合求出可用地址数，然后单独算出第三个 IP 地址可用地址数，两个地址数相加即正确答案。</p><p>【第二种情况】如未来教育上机考试第三套试题第10题：<br>“ IP 地址块 202.113.79.0/27、202.113.79.32/27、202.113.79.64/26 经过聚合后可用的地址数为___”</p><p>本题中“/”后边的数字前两个是相同的，第三个与前两个不同。<br>所以遇到这种题，直接将三个 IP 聚合得到地址块，然后求出三个 IP 的可用地址数。</p><h4 id="2-1-7-路由表距离更新"><a href="#2-1-7-路由表距离更新" class="headerlink" title="2.1.7 路由表距离更新"></a>2.1.7 路由表距离更新</h4><p>例：R1,R2 是一个系统中采用RIP路由协议的两个相邻路由器，R1 的路由表如（a）所示，<br>R1 收到 R2 发送的报文（b）后，R1 更新后的距离值从上到下依次是（ ）<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/17.1.13.jpg" alt="img"><br>解：做法如下<br>步骤为：b距离+1；<img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/3599406.png" alt="img"><br>与a距离比较；更新为距离最小的。则更新后的距离值从上到下依次是 0、4、4、3、2</p><p>还经常这样考——给出更新后距离值和（a）中的距离，求（b）报文距离的可能值。<br>规则不变，上面的做法反过去求就行。</p><h4 id="2-1-8-IPv6-地址简化表示"><a href="#2-1-8-IPv6-地址简化表示" class="headerlink" title="2.1.8 IPv6 地址简化表示"></a>2.1.8 IPv6 地址简化表示</h4><p>例：某地址 FF23:0:0:0:0510:0:0:9C5B，<br>可以简化为 FF23::0510:0:0:9C5B，双冒号替代连续出现的 0 位段，<br>不能简化为 FF23::0510::9C5B，因为双冒号只能使用一次，<br>可以简化为 FF23::510:0:0:9C5B，因为 0510 就是 510 ，<br>不能简化为 FF23::051:0:0:9C5B，因为 0510 不是 51。</p><p>例：下列 IPv6 地址表示中错误的是（ ）<br>A) ::10F:BC:0:0:03DA<br>B) FE::0:45:03/48<br>C) FE31:0:BC:3E:0:050D:BC::03DA<br>D) FF34:42:BC::3E:50F:21:03D<br>解：IPv6 地址是 128 位划分为 8 段的地址，而 C 项不算双冒号那段已经有了 8 段，双冒号又至少压缩一个 0 位段，所以超了 8 段，是错误的。<br>B 中的 /48 做题时可以忽略，写不写没关系。做这种题先看有没有包含两个** :: **的选项，再看最长的那项有没有超过 8 段。</p><h4 id="2-1-9-数据包"><a href="#2-1-9-数据包" class="headerlink" title="2.1.9 数据包"></a>2.1.9 数据包</h4><p>例：下图是 A 发送的数据包通过路由器转发到 B 的过程示意图，求数据包 3 中的<strong>目的IP地址</strong>和<strong>目的MAC地址</strong><br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/5.1.2.jpg" alt="img"><br>解：无论哪个数据包，目的 IP 地址就是 B 的 IP 地址，所以数据包 3 的目的 IP 为 129.42.56.216；<br>而目的 MAC 地址就是下一个路由器的 MAC 地址，数据包 3 的下一个路由器是 R3，所以数据包 3 的目的 MAC 地址是 00d0.63c3.3c41。</p><h4 id="2-1-10-三种备份"><a href="#2-1-10-三种备份" class="headerlink" title="2.1.10 三种备份"></a>2.1.10 三种备份</h4><p>备份速度从快到慢：增量备份、差异备份、完全备份（备份越详细越慢）<br>恢复速度从快到慢：完全备份、差异备份、增量备份（和上面顺序相反，也好理解，备份时详细的恢复快）<br>空间占用从多到少：完全备份、差异备份、增量备份（备份越详细占用空间越多）<br>题目通常问你其中某一种的顺序。<br>【补充】恢复备份时使用的备份数的顺序，使用备份数最多的是增量备份，最少的是完全备份。</p><h3 id="2-2-第二类选择题"><a href="#2-2-第二类选择题" class="headerlink" title="2.2 第二类选择题"></a>2.2 第二类选择题</h3><p>这部分将进一步体现本指南的优越性<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/8793453.png" alt="img"><br>我们先来看一道“第二类选择题”的四个选项，不需要看题。</p><p>-从这开始<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/6930046.png" alt="img"><br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/6950593.png" alt="img"><br>-到这结束<br>看起来异常复杂，但这是在我完全不懂知识点的情况下就能选对的题。<br><strong>下面要讲的是技巧方法，不是知识点，适用于这类题</strong><br>首先，你需要来回观察这四个选项，找出他们的不同点。可能是两句颠倒的代码，可能是一个单词一个数，也可能是其他的。<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/10244390.png" alt="img"><br>这是我把他们不同的地方做了荧光标记<br>首先一眼看上去，C 项的大段数字位置和其他三项不一样，所以排除 C；<br>然后，看蓝色的数字，只有 A 项和其他三项不一样，所以排除 A；<br>最后，看绿色的地方，只有 B 项少了一句，所以排除 B；<br>选 D。</p><p>悟性比较高的同学肯定已经明白了，为了大家更好的体会，再换一道题演示：<br>不先写选项了，直接展示标记后的<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/11098437.png" alt="img"><br>方法一样，找出不同点，然后“少数服从多数”，最后选 C。</p><p>下面一道题自己练习一下<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/7487171.png" alt="img"><br>答案是C。</p><p>说出来你可能不信，这种方法可以解决80%以上的“第二类选择题”，<br>有的题可能没办法排除掉三个选项，这时候就要结合一下题目内容推断来做或者蒙。</p><h3 id="2-3-第三类选择题"><a href="#2-3-第三类选择题" class="headerlink" title="2.3 第三类选择题"></a>2.3 第三类选择题</h3><p>下面列举的是高频考点，需要记忆，但不要死记。一开始可能感觉很陌生很难，做题碰见得多了就熟悉了能迅速选出答案。</p><h4 id="2-3-1-弹性分组环-RPR"><a href="#2-3-1-弹性分组环-RPR" class="headerlink" title="2.3.1 弹性分组环 RPR"></a>2.3.1 弹性分组环 RPR</h4><ul><li>每一个节点都执行<strong>SRP</strong>公平算法</li><li>与 FDDI 一样使用<strong>双环结构</strong></li><li>传统的 FDDI 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由<strong>源结点</strong>从环中回收</li><li>而 RPR 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由<strong>目的结点</strong>从环中回收</li><li>RPR 采用自愈环设计思路，能在 <strong>50ms</strong> 时间内隔离故障结点和光纤段</li><li>两个 RPR 结点间的裸光纤最大长度可达 <strong>100公里</strong></li><li>RPR 的外环（顺时针）和内环（逆时针）<strong>都可以</strong>用于传输分组和控制分组</li></ul><h4 id="2-3-2-无线接入技术"><a href="#2-3-2-无线接入技术" class="headerlink" title="2.3.2 无线接入技术"></a>2.3.2 无线接入技术</h4><ul><li>主要有 WLAN、WiMAX、WiFi、WMAN 和 Ad hoc ( WiFi 肯定知道，记住无线技术一般是W开头的，但有个特殊的A开头)</li><li>APON 不是无线传输技术，这个经常是迷惑项</li></ul><h4 id="2-3-3-城域网-QoS"><a href="#2-3-3-城域网-QoS" class="headerlink" title="2.3.3 城域网 QoS"></a>2.3.3 城域网 QoS</h4><p>题库有一道题中说 QoS是广域网的缩写 可能是写错了<br>考的时候通常只写英文缩写，下面写上中文名是为了方便你记忆（其他的地方也应该养成粗略推测英文缩写的习惯）</p><ul><li>主要的技术有 资源预留（<strong>RSVP</strong>）、区分服务（<strong>DiffServ</strong>）、多协议标记交换（<strong>MPLS</strong>）</li></ul><h4 id="2-3-4-接入技术特征"><a href="#2-3-4-接入技术特征" class="headerlink" title="2.3.4 接入技术特征"></a>2.3.4 接入技术特征</h4><ul><li>ADSL 使用一对铜双绞线，具有<strong>非对称</strong>技术特性，上行速率 64 kbps<del>640 kbps，下行速率 500 kbps</del>7 Mbps</li><li>采用 ADSL 技术可以通过 PSTN 接入 Internet</li><li>Cable Modom（电缆调制解调器）利用<strong>频分复用</strong>的方法将信道分为上行信道和下行信道，把用户计算机与有线电视同轴电缆连接起来</li><li>光纤传输距离可达 100km 以上（这个知道光纤很远就行了）</li></ul><h4 id="2-3-5-服务器技术"><a href="#2-3-5-服务器技术" class="headerlink" title="2.3.5 服务器技术"></a>2.3.5 服务器技术</h4><ul><li>热插拔功能允许用户在不切断电源的情况下更换硬盘、板卡等（不能更换主板卡）</li><li>集群技术中，如果一台主机出现故障，不会影响正常服务，但会影响系统性能</li><li>磁盘性能表现在储存容量和 I/O 速度（I/O=input/output 即输入/输出，学过计算机应该知道）</li><li>服务器总体性能取决于 CPU 数量、CPU 主频、系统内存、网络速度</li></ul><h4 id="2-3-6-综合布线"><a href="#2-3-6-综合布线" class="headerlink" title="2.3.6 综合布线"></a>2.3.6 综合布线</h4><ul><li>双绞线可以避免电磁干扰</li><li><strong>嵌入式插座</strong>用来连接双绞线</li><li><strong>多介质插座</strong>用来连接铜缆和光纤，满足用户“光纤到桌面”的需求</li><li>建筑群子系统可以是多种布线方式的任意组合，<strong>地下管道布线</strong>是最理想的方式</li><li>STP 比 UTP 贵、复杂、抗干扰能力强、辐射小</li><li>水平布线子系统电缆长度在 90 m 以内</li><li>干线线缆铺设经常采用点对点结合和分支结合两种方式</li></ul><h4 id="2-3-7-BGP-协议"><a href="#2-3-7-BGP-协议" class="headerlink" title="2.3.7 BGP 协议"></a>2.3.7 BGP 协议</h4><ul><li>BGP 是<strong>边界网关协议</strong>，而不是内部网关协议（所以遇到问某两个自治系统之间使用什么协议，就选 BGP）</li><li>BGP 交换路由信息的节点数不小于自治系统数</li><li>一个 BGP 发言人使用 <strong>TCP</strong>（不是UDP）与其他自治系统的 BGP 发言人交换信息</li><li>BGP 采用路由向量协议，而 RIP 采用距离向量协议</li><li>BGP 发言人通过 update 而不是 noticfication 分组通知相邻系统</li><li>open 分组用来与相邻的另一个 BGP 发言人建立关系，两个 BGP 发言人需要周期性地交换 keepalive 分组来确认双方的相邻关系</li></ul><h4 id="2-3-8-RIP-协议"><a href="#2-3-8-RIP-协议" class="headerlink" title="2.3.8 RIP 协议"></a>2.3.8 RIP 协议</h4><ul><li>RIP 是内部网关协议中使用最广泛的一种协议，它是一种分布式、基于距离向量的路由选择协议，要求路由器周期性地向外发送路由刷新报文</li><li>路由刷新报文主要内容是由若干个（V，D）组成的表。V 标识该路由器可以到达的目标网络（或目的主机）；D 指出该路由器到达目标网络（或目标主机）的距离。距离D对应该路由器上的跳数。其他路由器在接收到某个路由器的（V，D）报文后，按照***最短路径原则***对各自的路由表进行刷新</li><li>使用 RIP v1 路由协议在配置网络地址时*<strong>无须给定子网掩码*</strong></li></ul><h4 id="2-3-9-OSPF-协议"><a href="#2-3-9-OSPF-协议" class="headerlink" title="2.3.9 OSPF 协议"></a>2.3.9 OSPF 协议</h4><ul><li>OSPF 是内部网关协议的一种，每个区域有一个 32 位的标识符，区域内路由器不超过 200 个</li><li>区域内每个路由器包含<strong>本区域的完整网络拓扑</strong>，而不是全网的情况（拓扑的意思是链接形式和位置关系之类的）</li><li>链路状态“度量”主要指费用、距离、延时、带宽等</li><li>OSPF 采用<strong>洪泛法</strong>交换链路状态信息</li></ul><h4 id="2-3-10-集线器"><a href="#2-3-10-集线器" class="headerlink" title="2.3.10 集线器"></a>2.3.10 集线器</h4><ul><li>工作在物理层，连接到一个集线器的所有结点共享一个冲突域</li><li>集线器不是基于 MAC 地址完成数据转发，而是用广播的方法</li><li>在链路中串接一个集线器可以监听数据包</li><li>每次只有一个结点能够发送数据，而其他的结点都处于接收数据的状态。这些结点执行CSMA/CD介质访问控制方法</li></ul><h4 id="2-3-11-交换机"><a href="#2-3-11-交换机" class="headerlink" title="2.3.11 交换机"></a>2.3.11 交换机</h4><ul><li>是一种工作在数据链路层的网络设备，基本功能是维护一个表示 MAC 地址和交换机端口对应关系的交换表</li><li>在源端口与目的端口间建立虚链接</li><li>具有三种交换模式：1.快速转发直通式，接收到前 14 个字节就转发数据；2.碎片丢弃式，缓存前 64 个字节；3.储存转发式，转发之前读取整个帧</li><li>三层交换机是具有部分路由器功能的交换机，用于加快大型局域网内部的数据交换</li></ul><h4 id="2-3-12-路由器"><a href="#2-3-12-路由器" class="headerlink" title="2.3.12 路由器"></a>2.3.12 路由器</h4><ul><li>丢包率是衡量路由器超负荷工作时的性能指标之一</li><li>背板能力决定路由器吞吐量</li><li>传统路由器一般采用共享背板的结构，高性能路由器一般采用交换式的结构</li><li>突发处理能力<strong>不是</strong>以最小帧间隔值来衡量的</li><li>语音视频业务对延时抖动要求较高</li><li>高端路由器应达到：无故障连续工作时间大于 10 万小时；故障恢复时间小于 30 分钟；切换时间小于 50 毫秒</li></ul><h4 id="2-3-13-IEEE-802-11"><a href="#2-3-13-IEEE-802-11" class="headerlink" title="2.3.13 IEEE 802.11"></a>2.3.13 IEEE 802.11</h4><ul><li>IEEE 802.11 最初定义的三个物理层包括了两个扩频技术和一个红外传播规范，无线频道定义在 2.4GHz ISM频段，传输速度 1~2 Mbps</li><li><strong>802.11b</strong> 最大容量 33Mbps，将传输速率提高到 <strong>11 Mbps</strong>，<strong>802.11a</strong>和<strong>802.11g</strong> 将传输速率提高到 <strong>54 Mbps</strong></li><li>IEEE 802.11b 标准使用的是开放的 2.4GHZ 频段，无须申请就可以直接使用</li><li>IEEE 802.1d 是当前最流行的 STP（生成树协议）标准</li></ul><h4 id="2-3-14-蓝牙"><a href="#2-3-14-蓝牙" class="headerlink" title="2.3.14 蓝牙"></a>2.3.14 蓝牙</h4><ul><li>同步信道速率 64 kbps，跳频速率为 1600 次/s</li><li>工作在 2.402 ~ 2.480 GHz 的 ISM 频段</li><li>非对称的异步信道速率为 723.2 kbps / 57.6 kbps</li><li>对称的异步信道速率为 433.9 kbps</li><li>发射功率为100mw时，最大传输距离为100米</li></ul><h4 id="2-3-15-Serv-U-FTP-服务器"><a href="#2-3-15-Serv-U-FTP-服务器" class="headerlink" title="2.3.15 Serv-U FTP 服务器"></a>2.3.15 Serv-U FTP 服务器</h4><ul><li>使用动态 IP 地址时，服务器 IP 地址应配置为空，而不是 0.0.0.0。（为空代表全部 IP 地址）</li><li>每个 Serv-U FTP 服务器中的虚拟服务器由 <strong>IP 地址和端口号</strong>唯一识别，而不是依靠 IP 地址</li><li>向服务器中添加“anonymous”，系统自动判定为匿名。而不是创建新域时自动添加一个“anonymous”匿名</li><li>服务器最大用户数是指服务器允许同时在线的最大用户数量</li><li>用户上传下载选项要求 FTP 客户端在下载信息的同时也要上传文件</li></ul><h4 id="2-3-16-DNS-服务器"><a href="#2-3-16-DNS-服务器" class="headerlink" title="2.3.16 DNS 服务器"></a>2.3.16 DNS 服务器</h4><ul><li>允许客户机在发生更改时动态更新其资源记录</li><li>DNS 服务器中的根服务器被自动加入到系统中，<strong>不需</strong>管理员手工配置</li><li>转发器是网络上的 DNS 服务器（不是路由器），用于外域名的 DNS 查询</li><li>使用 nslookup 命令可以测试正向和反向查找区域</li><li>主机记录的生存时间指该记录被客户端查询到，放在缓存中的持续时间</li></ul><h4 id="2-3-17-DHCP-服务器"><a href="#2-3-17-DHCP-服务器" class="headerlink" title="2.3.17 DHCP 服务器"></a>2.3.17 DHCP 服务器</h4><ul><li>负责多个网段 IP 地址分配时需配置<strong>多个作用域</strong></li><li>添加保留时需在 DHCP 客户机上获得其 MAC 地址信息（<strong>添加排除时不需</strong>从客户端获得 MAC 地址）<br>-不添加排除和保留时，服务器可将地址池内的 IP 地址动态指派给 DHCP 客户机<br>-地址池是作用域应用排除范围之后剩余的 IP 地址<br>-保留是指确保 DHCP 客户端永远可以得到同一 IP 地址，客户端<strong>可以释放</strong>该租约<br>-收到非中继转发的“DHCP发现”消息时,选择收到该消息的子网所处的网段分配 IP 地址</li></ul><h4 id="2-3-18-WWW-服务器"><a href="#2-3-18-WWW-服务器" class="headerlink" title="2.3.18 WWW 服务器"></a>2.3.18 WWW 服务器</h4><ul><li>Web 站点可以配置<strong>静态</strong>和<strong>动态</strong> IP 地址<br>-访问 Web 站点时可以使用站点的域名或站点的 IP 地址<br>-建立 Web 站点时必须为该站点指定一个主目录，也可以是虚拟的子目录<br>-Web 站点的性能选项包括影响带宽使用的属性和客户端 Web 连接的数量<br>-在 Web 站点的主目录选项卡中，可配置主目录的读取和写入等权限</li></ul><h4 id="2-3-19-Wmail-邮件服务器"><a href="#2-3-19-Wmail-邮件服务器" class="headerlink" title="2.3.19 Wmail 邮件服务器"></a>2.3.19 Wmail 邮件服务器</h4><ul><li>Winmail 用户<strong>不可以</strong>使用 Outlook 自行注册新邮箱</li><li>Winmail 快速设置向导中创建新用户时，输入新建用户的信息，包括用户名、域名及用户密码（不是系统邮箱的密码）</li><li>建立路由时，需在 DNS 服务器中建立该邮件服务器主机记录和邮件交换器记录</li><li>邮件系统工作过程：1.用户在客户端创建新邮件；2.客户端软件使用 SMTP 协议将邮件发到<strong>发件方的邮件服务器</strong>；3.发件方邮件服务器使用 SMTP 协议将邮件发到<strong>收件方的邮件服务器</strong>；4.接收方邮件服务器将收到邮件储存待处理；5.接收方客户端软件使用 POP3 或 IMAP4 协议从邮件服务器读取邮件</li><li>邮件交换器记录的配置只能在服务器上，不能通过浏览器配置</li><li>Winmail 支持基于 Web 方式的访问和管理，管理工具包括系统设置、域名设置等</li><li>发送邮件时通常采用 SMTP 协议，接收邮件时通常采用 POP3 或者 IMAP 协议。Winmail 用户使用浏览器查看邮件会使用到 HTTP 协议</li></ul><h4 id="2-3-20-PIX-防火墙"><a href="#2-3-20-PIX-防火墙" class="headerlink" title="2.3.20 PIX 防火墙"></a>2.3.20 PIX 防火墙</h4><ul><li><strong>监视模式</strong>中，可以更新操作系统映像和口令恢复</li><li>防火墙开机自检后处于非特权模式，输入“enable”进入特权模式</li></ul><h4 id="2-3-21-可信计算机评估准则"><a href="#2-3-21-可信计算机评估准则" class="headerlink" title="2.3.21 可信计算机评估准则"></a>2.3.21 可信计算机评估准则</h4><ul><li>没有保护就是 D类，不能用于多用户环境下重要信息处理</li><li>提到用户<strong>自主保护</strong>就是 C类</li></ul><h4 id="2-3-22-入侵防护系统"><a href="#2-3-22-入侵防护系统" class="headerlink" title="2.3.22 入侵防护系统"></a>2.3.22 入侵防护系统</h4><ul><li>HIPS 基于主机的入侵防护系统，安装在受保护的主机系统中</li><li>NIPS 基于网络的入侵防护系统，布置在网络出口</li><li>AIPS 基于应用的入侵防护系统，部署于应用服务器前端<br>（他们的首字母 H、N、A 即 Host、Net、Application）</li></ul><h4 id="2-3-23-网络攻击"><a href="#2-3-23-网络攻击" class="headerlink" title="2.3.23 网络攻击"></a>2.3.23 网络攻击</h4><ul><li>DDos 攻击：利用已经攻占的多个系统向目标攻击，被害设备面对大量请求无法正常处理而拒绝服务</li><li><strong>SYN Flooding 攻击：利用 TCP 三次握手过程</strong>，使受害主机处于会话请求之中，直至连接超时停止响应</li><li>SQL 注入攻击：属于利用系统漏洞，防火墙（基于网络的防护系统）<strong>无法阻断</strong></li><li>Land攻击：向某个设备发送数据包，并将数据包的源 IP 地址和目的地址都设置成攻击目标的地址</li><li>基于网络的防护系统也无法阻断 Cookie篡改 和 DNS欺骗</li><li><strong>Teardrop 、Smurf 攻击可以被路由器阻止</strong></li></ul><h4 id="2-3-24-无线局域网设备"><a href="#2-3-24-无线局域网设备" class="headerlink" title="2.3.24 无线局域网设备"></a>2.3.24 无线局域网设备</h4><ul><li>无线接入点（AP）：集合无线或者有线终端（类似于集线器和交换机），负责频段管理和漫游工作（SSID 是客户端设备用来访问接入点的唯一标识）</li><li>无线路由器：具有无线路由功能和 NAT 功能的 AP ，可用来建立小的无线局域网。</li><li>无线网桥：用于连接几个不同的网段，实现较远距离的无线通信（网桥最重要的维护工作是构建和维护 MAC 地址表）</li><li>无线网卡：实现点对点通信，安装于各终端节点</li></ul><h4 id="2-3-25-VLAN"><a href="#2-3-25-VLAN" class="headerlink" title="2.3.25 VLAN"></a>2.3.25 VLAN</h4><ul><li>VLAN name 用 1~32 个字符表示，它可以是字母和数字。不给定名字的 VLAN 系统自动按缺省的 VLAN 名（VLAN00xxx）</li><li>VLAN ID的取值范围是 1~4094。其中无法执行“no vlan 1”命令</li></ul><h4 id="2-3-26-Cisco-路由器上的存储器"><a href="#2-3-26-Cisco-路由器上的存储器" class="headerlink" title="2.3.26 Cisco 路由器上的存储器"></a>2.3.26 Cisco 路由器上的存储器</h4><ul><li>Flash 主要用于存储当前使用的操作系统映像文件和微代码<br>-NVRAM 主要存储启动配置文件或备份配置文件<br>-RAM 主要存储路由表、快速交换缓存、ARP 缓存、数据分组缓冲区和缓冲队列、运行配置文件等<br>-ROM 主要用来永久保存路由器的开机诊断程序、引导程序和操作系统软件</li></ul><h4 id="2-3-27-防火墙对应端口的连接方案"><a href="#2-3-27-防火墙对应端口的连接方案" class="headerlink" title="2.3.27 防火墙对应端口的连接方案"></a>2.3.27 防火墙对应端口的连接方案</h4><p>pix525 在缺省情况下</p><ul><li>ethernet0 被命名为外部接口 outside，安全级别是 0</li><li>ethernet1 被命名为内部接口 inside，安全级别是 100</li><li>ethernet2 被命名为中间接口 dmz，安装级别是 50</li></ul><h4 id="2-3-28-STP-生成树结构"><a href="#2-3-28-STP-生成树结构" class="headerlink" title="2.3.28 STP 生成树结构"></a>2.3.28 STP 生成树结构</h4><ul><li>无论是根的确定，还是树状结构的生成，主要依靠 BPDU 提供的信息<br>-Bridge ID 由两个字节的优先级值和 6 个字节的交换机 MAC 地址组成，优先级取值范围是0~61440，增值量是4096，优先值越小，优先级越高<br>-MAC 地址最小的为根网桥<br>-BPDU 数据包有两种类型，配置 BPDU 不超过 35 个字节，拓扑变化通知 BPDU 不超过 4 个字节</li></ul><h4 id="2-3-29-Catelyst-配置命令"><a href="#2-3-29-Catelyst-配置命令" class="headerlink" title="2.3.29 Catelyst 配置命令"></a>2.3.29 Catelyst 配置命令</h4><ul><li>Catelyst3548 设置时间的格式是：clock set 小时:分钟:秒 日 月 年</li><li>Catelyst6500 设置时间的格式是：set time 星期 月/日/年 小时 分钟 秒</li></ul><h4 id="2-3-30-其他"><a href="#2-3-30-其他" class="headerlink" title="2.3.30 其他"></a>2.3.30 其他</h4><p>有一些知识点因为考频不是很高或者比较复杂，就不写了，自己做题时积累或者放弃。</p><p>在遇到陌生题目时，试着结合常识思考推断。<br>比如说，某网络计划有三台计算机，但只有一个 VLAN 端口，需要的设备是（）<br>这里需要的其实就是路由器，联想宿舍上网的情况</p><h2 id="3-大题（前四道每道10分，最后一道20分）"><a href="#3-大题（前四道每道10分，最后一道20分）" class="headerlink" title="3.大题（前四道每道10分，最后一道20分）"></a>3.大题（前四道每道10分，最后一道20分）</h2><h3 id="3-1-第一道-填地址表"><a href="#3-1-第一道-填地址表" class="headerlink" title="3.1 第一道 填地址表"></a>3.1 第一道 填地址表</h3><p>例：</p><table><thead><tr><th>IP 地址</th><th>115.151.29.58</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.240.0.0</td></tr><tr><td>地址类别</td><td>【1】</td></tr><tr><td>网络地址</td><td>【2】</td></tr><tr><td>直接广播地址</td><td>【3】</td></tr><tr><td>主机号</td><td>【4】</td></tr><tr><td>子网内第一个可用 IP 地址</td><td>【5】</td></tr></tbody></table><p>解：</p><table><thead><tr><th>IP 地址类别</th><th>IP 首段范围</th></tr></thead><tbody><tr><td>A类</td><td>1~127</td></tr><tr><td>B类</td><td>128~191</td></tr><tr><td>C类</td><td>192~223</td></tr></tbody></table><p>则【1】填：A类<br>对 IP地址和子网掩码做如下处理：<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/6325296.png" alt="img"><br>熟练以后其实没有看起来这么麻烦，做两道就会了。少数情况会给出表格的后两项，让你补充前五项，原理其实是一样的，倒推一下。<br>这道题是大题里面考点最稳定的一道，必须掌握。</p><h3 id="3-2-第二道-配置路由器"><a href="#3-2-第二道-配置路由器" class="headerlink" title="3.2 第二道 配置路由器"></a>3.2 第二道 配置路由器</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220322200007512.png" alt="image-20220322200007512"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220319105631191.png" alt="image-20220319105631191"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220322200035234.png" alt="image-20220322200035234"></p><p>例：<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/11125734.png" alt="img"><br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/14626890.png" alt="img"><br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/11178875.png" alt="img"><br>一般就考这些空，做几道之后就能填上大部分，小部分可以放弃。</p><p>【来自张斌的修改建议，由于不方便改图就直接贴在这里了】network ______ area 0和#area 0 range _______，这两个空的讲解可以修改为“R3所在的子网号+子网掩码的反码/子网掩码，如果有两个子网号则先对两个子网进行聚合，然后填写聚合后的子网号+子网掩码的反码/子网掩码”，因为就题库中的题目而言，有两个子网号的情况还是挺多的。除此之外，还可以增加当配置R4时的#ip route _____，空里应该是目的网络子网号（与上题同）+子网掩码（与上题同）+下一跳路由器地址（R3的地址），阴影中有两个子网号时同样先进行聚合。R3由于本身就是阴影区域的一部分，故目的网络和目的子网掩码都是0.0.0.0。同理，如果配置R1或R2，他们都是阴影区域的一部分，目的网络与子网掩码也都是0.0.0.0。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323213106214.png" alt="image-20220323213106214"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323213205941.png" alt="image-20220323213205941"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323213233250.png" alt="image-20220323213233250"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323213446271.png" alt="image-20220323213446271"></p><h3 id="3-3-第三道-DHCP-报文"><a href="#3-3-第三道-DHCP-报文" class="headerlink" title="3.3 第三道 DHCP 报文"></a>3.3 第三道 DHCP 报文</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323214409376.png" alt="image-20220323214409376"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323214512057.png" alt="image-20220323214512057"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323214611784.png" alt="image-20220323214611784"> </p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323220515411.png" alt="image-20220323220515411"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323220740127.png" alt="image-20220323220740127"></p><p>例：<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/12762453.png" alt="img"><br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/12772953.png" alt="img"></p><h3 id="3-4-第四道-sniffer-数据包"><a href="#3-4-第四道-sniffer-数据包" class="headerlink" title="3.4 第四道 sniffer 数据包"></a>3.4 第四道 sniffer 数据包</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220319154813724.png" alt="image-20220319154813724"></p><p>例1：<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/20802828.png" alt="img"><br>根据图中信息回答以下问题</p><ol><li>该主机执行的命令是（ ），该主机配置的 DNS 服务器的 IP 地址是（ ）<br>解：看图中有 ICMP 几个字母，还有个邮箱地址，所以命令是 tracert mail.tj.edu.cn，DNS服务器的 IP 地址是第一行第二个地址 202.113.64.3（只要这么问，就基本是第一行第二个）</li><li>图中 ② ③ ④ 处分别是（ ）<br>解：② 处前面 Protocol 意思是协议，协议就是 ICMP；③ 写源地址，就是第一行第一个地址 202.113.64.137；④ Destination address 意思是目的地址，这个位置应该写题中有的网址 mail.tj.edu.cn。</li></ol><p>例2：<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/22076937.png" alt="img"><br>根据图中信息回答以下问题</p><ol><li>该主机配置的域名服务器的 IP 地址是（ ）<br>解：和上题一样，还是第一行第二个 202.113.64.3</li><li>① 处的信息应该是（ ）<br>解：填 ACK。一般都是有一个 SEQ，后再有一个 ACK，接着再有 SEQ，再有 ACK。他们的数值每次 +1，有时候会根据上下行填数字。</li><li>主机 202.38.97.197 是（ ）服务器，其提供服务的端口是（ ）<br>解：因为图中有 FTP 几个字母，所以这是 ftp服务器；提供服务的端口是 21（DNS服务器的端口是 53，邮件服务器的端口是 6）</li><li>该主机执行的命令是（ ）<br>解：填 ftp ftp.pku.edu.cn（网站在图中，前面加 ftp）</li></ol><p>这道题通常就考上面这两种模式，一种有 ICMP 对应 tracert mail.tj.edu.cn 的，一种有 FTP 对应 ftp ftp.pku.edu.cn 的。<br>如果让写 URL 就是 https :// mail.tj.edu.cn 或者 ftp :// ftp.pku.edu.cn（中间都没有空格，我为了格式不自动转换成链接才加的）</p><p>第四道大题也是考点很不稳定的一道。</p><h3 id="3-5-最后一道"><a href="#3-5-最后一道" class="headerlink" title="3.5 最后一道"></a>3.5 最后一道</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323213848363.png" alt="image-20220323213848363"></p><p><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/755234.png" alt="img"></p><h4 id="3-5-1-填表部分（12分）"><a href="#3-5-1-填表部分（12分）" class="headerlink" title="3.5.1 填表部分（12分）"></a>3.5.1 填表部分（12分）</h4><table><thead><tr><th>目的网络/掩码长度</th><th>输出端口</th></tr></thead><tbody><tr><td>【1】</td><td>S0（直接连接）</td></tr><tr><td>【2】</td><td>S1（直接连接）</td></tr><tr><td>【3】</td><td>S0</td></tr><tr><td>【4】</td><td>S1</td></tr><tr><td>【5】</td><td>S0</td></tr><tr><td>【6】</td><td>S1</td></tr></tbody></table><p>解：图中最上方的 RG 有两个分支，左侧分支是 S0 ，有末段为 129 和 130 的两个地址，进行聚合：<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/2146703.png" alt="img"><br>所以【1】处填 192.168.6.128/30 ；同理【2】处是 192.168.6.133 和 192.168.6.134 聚合，结果为 192.168.6.132/30。<br>做题实际上只要写出最后那段就行，前面选择题时已经说过了。</p><p>【3】是 RE 下方 192.168.6.<strong>65</strong>、192.168.6.<strong>66</strong>、192.168.6.<strong>67</strong> 三个子网的聚合；<br>【4】是 RF 下方 192.168.6.<strong>80</strong>、192.168.6.<strong>81</strong>、192.168.6.<strong>82</strong> 三个子网的聚合；<br>【5】是 左下方 192.168.<strong>64</strong>.0/24、192.168.<strong>65</strong>.0/24、192.168.<strong>66</strong>.0/24、192.168.<strong>67</strong>.0/24 四个地址块的聚合；<br>【6】是 右下方 192.168.<strong>96</strong>.0/24、192.168.<strong>97</strong>.0/24、192.168.<strong>98</strong>.0/24、192.168.<strong>99</strong>.0/24 四个地址块的聚合；</p><p>在【3】【4】两空聚合时往往需要多注意<br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/15416703.png" alt="img"><br><img src="https://vipkshttps13.wiz.cn/ks/share/resources/96ea5f9a-14bf-4265-bd6b-d743661380a3/17a07dd6-03ce-4635-88b0-bc49dabfd7f4/index_files/15517109.png" alt="img"> 最终答案应为<br>【3】192.168.6.64/29<br>【4】192.168.6.64/27<br>【5】192.168.64.0/22<br>【6】192.168.96.0/22</p><p>这个填表是必拿分的题。</p><h4 id="3-5-2-中间部分（2-4分）"><a href="#3-5-2-中间部分（2-4分）" class="headerlink" title="3.5.2 中间部分（2~4分）"></a>3.5.2 中间部分（2~4分）</h4><p>这部分考点很不固定，下面是频率稍高的，考试这几分放弃也可以</p><ul><li>问在某路由器上，最多还可链接的路由器数量是多少。如果所在子网掩码是 /29 就填 3，是 /28 就填 11。</li><li>问串接一种设备能监听路由器之间的流量，写 TAP</li><li>问串接一种设备能提供安全保护，一般是 IPS</li><li>问防火墙访问外网设置，分别填 nat 和 global</li></ul><h4 id="3-5-3-计算子网掩码和-IP-段部分（4-6分）"><a href="#3-5-3-计算子网掩码和-IP-段部分（4-6分）" class="headerlink" title="3.5.3 计算子网掩码和 IP 段部分（4~6分）"></a>3.5.3 计算子网掩码和 IP 段部分（4~6分）</h4><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220323214052213.png" alt="image-20220323214052213"></p><p>例：将 192.168.66.128/25 划分为三个子网，子网 1 能容纳 50 台主机，子网 2 和 3 能分别容纳 20 台主机……求他们的子网掩码和可用 IP 地址段</p><p>解：题中说多少台主机的具体数字不重要，刚好大于那个数字加 2 后的 2 的 n 次方的数才重要。<br>比如 50 台，就是 64，是 2 的 6 次方。所以子网掩码后 6 位都是 0 （前面全是 1 ），11111111.11111111.11111111.11000000 ，最后填空写 255.255.255.192<br>同理 20 台，就是 32，是 2 的 5次方。所以子网掩码后 5位都是 0，最后填空 2 和 3 的子网掩码都是 255.255.255.224</p><p>可用 IP 地址从题目所给的那个数 +1 开始，本题是 192.168.66.129（因为太乱，下面只写末段数字，反正前面都一样）<br>从 129 开始，因为子网 1 的那个数字是 64 ，所以到 190 结束（129+64**-3**=190，不用管为什么，结束都是 -3）<br>下一段从 193 开始（190**+3**=193，不用管为什么，开始都是 +3），因为子网 2 的那个数字是 32 ，所以到 222 结束（193+32**-3**=222）<br>再下一段从 225 开始（222**+3**=225），因为子网 3 的那个数字也是 32 ，所以到 254 结束（225+32**-3**=254）<br>写成答案分别为：<br>子网 1 的可用 IP 地址段为 192.168.66.129<del>192.168.66.190<br>子网 2 的可用 IP 地址段为 192.168.66.193</del>192.168.66.222<br>子网 3 的可用 IP 地址段为 192.168.66.225~192.168.66.254</p><p>看起来上面写了一大堆，其实明白了就很简单，这个也是必拿分的题。</p><hr><h2 id="总结：得分策略"><a href="#总结：得分策略" class="headerlink" title="总结：得分策略"></a>总结：得分策略</h2><p>目标是通过考试，也就是 60 分</p><ul><li>选择题部分：前面一共写了 10 个做法固定的“第一类选择题”，还有 19 个“第三类选择题”的高频考点，加上“第二类选择题”。选择题得分在 20 分以上是很保守的估计，没有意外的话选择题应该在 25 分以上。</li><li>大题部分：第一道的 10 分是必得的，最后一道除了中间部分后有 16 分是必得的。从前面写的也能看出第二、三、四道大题的考点不是特别固定，所以尽量写，填对一半就很好了（其实也没有那么难），所以这三道大题 30 分目标是得 15 分。<br>【2018/9/6补充】有时间可以去b站看看正规的大题讲解视频，也许第二、三、四道大题的做法并不难。现在看来我当时的想法还是消极了一些（不过还是一定要先学会固定的题型再说）</li></ul><p>来算一下 20 + 10 + 16 + 15 = 61 分。实际情况当然可能会出现意外，比如三道大题没得到 15 分，但刚才也没算你蒙对的题得分。</p><p>多练习几套题，来回对照着知识点就熟悉了，这个考试题型固定，含金量不高，难度不大，不用害怕。题库软件有很多缺陷，比如大题评分不准、填空题缺少空格，甚至是答案错误。自己要注意核对。这份文档并未涵盖所有知识点，多做一套题就多了一分考过的把握。</p><p>（未来教育题库的第九套题有点特殊，看起来像 13 年考试改革之前的老题，和其他套的题有很大差别，留意一下。）</p><p>完。<br>2017/3/19 初版<br>2017/4/25 修改了前言与总结<br>2017/5/12 修改内容略<br>2017/5/16 刚查到成绩，84分，本来还以为能上90…<br>2017/8/23 补充了备考建议<br>2017/9/12 改正了 2.1.6 IP地址块聚合<br>2017/9/21 增加了 2.3 中近一半的内容，感谢佚名进行的补充<br>2017/12/18 考试获证条件改变，三级不再需要对应的二级科目通过<br>2018/3/24 修正了若干错误，感谢何林刚、张斌、fun、sang_wang 等的帮助<br>2018/6/6 末尾加了收款码<br>2019/2/10 修改两处笔误等</p><p>每次更新编辑会导致分享页面审核，影响同学复习，所以我一般不更新了</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 计算机三级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置OpenGL C++ 开发环境</title>
      <link href="/2022/03/20/use-vcpkg-to-manage-cpp-libs/"/>
      <url>/2022/03/20/use-vcpkg-to-manage-cpp-libs/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这学期新开了计算机图形学的课程，第一次作业就是配置<code>OpenGL</code>开发环境。配置环境对于许多人来说都是头疼的问题，我也不例外。</p><p>​    这里我提供两种配置环境的方法供参考。</p><ul><li>使用<code>Vcpkg</code>进行配置（强烈推荐）</li><li>使用<code>Visual Studio</code>内部手动设置（很麻烦）</li></ul><h1 id="使用-Vcpkg-配置"><a href="#使用-Vcpkg-配置" class="headerlink" title="使用 Vcpkg 配置"></a>使用 Vcpkg 配置</h1><h2 id="什么是Vcpkg"><a href="#什么是Vcpkg" class="headerlink" title="什么是Vcpkg?"></a>什么是<code>Vcpkg</code>?</h2><blockquote><p>Vcpkg 可帮助您在 Windows、 Linux 和 MacOS 上管理 C 和 C++ 库。</p><p>它是一个开源的包管理工具</p></blockquote><p>在<code>Github</code>上有相关的仓库，具体的配置可以参考官方的说明文档，有中文版👉<a href="https://github.com/microsoft/vcpkg/blob/master/README_zh_CN.md">链接</a></p><p>如果你比较懒，那么请看我下面简易的讲解。</p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="配置-vcpkg"><a href="#配置-vcpkg" class="headerlink" title="配置 vcpkg"></a>配置 vcpkg</h3><p>​    首先，根据官方推荐 ，可在C盘新建一个 <code>src </code>文件夹（<code>C:\src</code>）</p><p>​    在该目录下运行 PowerShell 或普通 cmd。运行以下命令下载<code>vcpkg</code>，执行<code>bootstrap-vcpkg.bat</code>脚本，并使其可在VS中使用</p><p>​    可将安装目录（如<code>C:\src\vcpkg</code>）添加进系统环境变量中以方便命令行调用</p><p>​    如未安装过Git需先下载安装 Git，并将Git所在目录添加进环境变量中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https://github.com/microsoft/vcpkg.\vcpkg\bootstrap-vcpkg.bat.\vcpkg\vcpkg integrate install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置-OpenGL"><a href="#配置-OpenGL" class="headerlink" title="配置 OpenGL"></a>配置 OpenGL</h3><p>目前最新的也是最推荐安装的IoenGL窗口相关第三方库为glfw，API相关第三方库为glad。运行下列命令安装。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.\vcpkg\vcpkg install glfw3 .\vcpkg\vcpkg install glad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>📌请注意: vcpkg在Windows中默认编译并安装x86版本的库。 若要编译并安装x64版本，请执行</p></blockquote><pre class="line-numbers language-she" data-language="she"><code class="language-she">&gt; .\vcpkg\vcpkg install [package name]:x64-windows<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来就可以在vs里直接include所需文件，不会产生编译和链接问题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>​    <code>vcpkg</code>方式配置的缺点就是因为是直接使用编译好的库，所以不方便查看源码。如有查看源码需求还是要使用自己编译相关库并链接进自己的工程的方式。但如只是想调用接口这种方式即可满足需求。如库有更新，可直接使用<code>vcpkg</code>进行更新。</p><h1 id="VS内部设置"><a href="#VS内部设置" class="headerlink" title="VS内部设置"></a>VS内部设置</h1><p>虽然挺麻烦,但是我建议自己跟着做一做，会加深你对<code>C++</code>引用第三方库的理解。</p><p>这里可以参考这篇文章👉<a href="https://blog.csdn.net/AvatarForTest/article/details/79199807?utm_source=app&amp;app_version=5.0.1&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">链接</a></p><h1 id="你可能会需要"><a href="#你可能会需要" class="headerlink" title="你可能会需要"></a>你可能会需要</h1><p><a href="https://blog.csdn.net/AvatarForTest/article/details/79199807?utm_source=app&amp;app_version=5.0.1&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">OpenGL+VS2017 环境配置(亲测好使)::附带必要知识点</a></p><p><a href="https://www.cnblogs.com/linuxAndMcu/p/14696542.html">C++开源库 - 包管理工具Vcpkg安装使用教程 </a></p><p><a href="https://blog.csdn.net/qq_39690181/article/details/82910610">解决vcpkg下载缓慢的问题</a></p><p><a href="https://learnopengl-cn.github.io/">OpenGL经典教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记_02</title>
      <link href="/2022/03/12/os-2-procession/"/>
      <url>/2022/03/12/os-2-procession/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h1><blockquote><p>📌所谓进程，就是运行中的程序。</p></blockquote><p>​    在计算机发展的早期，处理器往往只有一个核心，因此就产生了<code>伪并行</code>（<code>pseudoparallelism</code>）即宏观上多线程同时运行，而微观上，各进程轮流使用 CPU,实际上任意一个时刻，只有一个进程在使用 CPU.</p><blockquote><p>随着计算机技术的不断发展，真正的并行已经可以实现了，现代 CPU 有多个核心，能够同时运行多道进程。</p></blockquote><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220320164311643.png">    ❗ 由于 CPU 不停地在不同进程之间进行切换，每个进程的执行速度往往不确定，所以在编程的时候不能对时序做固定的假设。</p><h2 id="进程与程序之间的关系"><a href="#进程与程序之间的关系" class="headerlink" title="进程与程序之间的关系"></a>进程与程序之间的关系</h2><ul><li>一个进程是某种类型的一个活动，它具有不可再现性</li><li>一个程序则是用适当形式描述的算法</li></ul><h3 id="计算机科学家做蛋糕例子"><a href="#计算机科学家做蛋糕例子" class="headerlink" title="计算机科学家做蛋糕例子"></a>计算机科学家做蛋糕例子</h3><p>​    想像一位有一手好厨艺的计算机科学家正在为他的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等等。在这个比喻中，<strong>做蛋糕的食谱就是程序</strong>(即用适当形式描述的算法)，<strong>计算机科学家就是处理机</strong>(CPU)，而做蛋糕的各种原料就是输入的数据。<strong>进程就是</strong>厨师阅读食谱、取来各种原料以及烘制蛋糕的<strong>一系列动作的总和</strong>。<br>​    现在假设汁算机科学家的女儿哭着跑了进来，说她被一只蜜蜂蛰了。计算机科学家就记录下自己照着食谱做到哪儿了(保存进程的当前状态)，然后拿出一本急救手册，按照其中的指示处理蜇伤。这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(实施医疗救治)，每个进程加有各自的程序(食谱和急救指示)。当蜜蜂蛰伤处理完之后，计算机科学家回来做蛋糕，从他离开时的那一步继续做下去(继续执行做蛋糕程序)。</p><h3 id="进程与程序的主要区别："><a href="#进程与程序的主要区别：" class="headerlink" title="进程与程序的主要区别："></a>进程与程序的主要区别：</h3><p> （1）程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</p><p> （2）程序是静态的观念，进程是动态的观念；</p><p> （3）进程具有并发性，而程序没有；</p><p> （4）进程是竞争计算机资源的基本单位，程序不是。</p><p> （5）进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序</p><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>进程创建一般有以下四种情况：</p><ol><li>系统初始化</li><li>正在运行的一个进程执行了创建进程的系统调用</li><li>用户请求创建一个新进程</li><li>批处理作业的初始化</li></ol><h3 id="系统调用-Fork"><a href="#系统调用-Fork" class="headerlink" title="系统调用 Fork"></a>系统调用 Fork</h3><p>​    简单来讲，调用<code>fork</code>函数后会产生一个新的子进程，父子进程共享相同的内存映像和环境字符串和相同的打开的文件。</p><blockquote><p> fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p></blockquote><p>  1）在父进程中，fork返回新创建子进程的进程ID；<br>  2）在子进程中，fork返回0；<br>  3）如果出现错误，fork返回一个负值；</p><p>详细讲解可以看👉<a href="https://blog.csdn.net/stpeace/article/details/38805369">fork函数详解</a></p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>一个进程被终止可能有以下原因：</p><p>​    1. 正常退出（自愿）</p><p>​                exit系统调用<br>2. 出错退出（自愿）</p><p>   ​    如打开一个不存在的文件</p><ol start="3"><li><p>严重错误（非自愿）</p><p>​    产生异常，比如除了零</p></li><li><p>被其他进程杀死（非自愿）</p><p>​    kill系统调用</p></li></ol><h2 id="进程层次结构"><a href="#进程层次结构" class="headerlink" title="进程层次结构"></a>进程层次结构</h2><p>​        进程只有一个父进程，但可以有多个子进程。子进程本身也可以创建它自己的子进程，这样也就组成了一个进程的层次结构。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>一个进程有下面三种状态：</p><ul><li>运行态<code>Running</code><ul><li>该时刻实际占用处理机</li></ul></li><li>就绪态<code>Ready</code><ul><li>可运行，但因为其他进程正在运行而暂时被挂起</li></ul></li><li>阻塞态<code>Blocked</code><ul><li>除非某种外部事件发生，否则不能运行</li></ul></li></ul><p>他们之间的关系与转换如下图：</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220320194220624.png"></p><ul><li>当某个进程在逻辑上不能继续运行时，它就会被阻塞<ul><li>等待使用别的输入</li><li>另一个进程占用处理机</li></ul></li><li>2、3两关系是由<code>进程调度器</code>引起的，它是操作系统的一部分</li><li>某进程等待的外部事件发生时，发生转换4</li></ul><h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程 thread"></a>线程 thread</h2><blockquote><p>📌某些情况下在同一个地址空间中由多个控制流并行运行，像是单独进程，但是它们<strong>共享相同的地址空间</strong></p></blockquote><p>举个很简单的例子😉</p><p>​        Office Word 是一个进程，而在这个进程里需要许多细分的小进程来处理你对 Word 的各种操作，比如改变字号、改变颜色、定时保存…这些小进程处理同一个 Word 文件，也就是说，他们共享同一片内存空间，我们就称这样的小进程为线程<code>threads</code>!</p><blockquote><p>😶线程和进程一样，都可以处于运行、就绪或阻塞态。</p></blockquote><h1 id="进程间通信问题"><a href="#进程间通信问题" class="headerlink" title="进程间通信问题"></a>进程间通信问题</h1><p><code>Inter Process Communication (IPC)</code>进程间通信</p><h2 id="通信需要解决的问题"><a href="#通信需要解决的问题" class="headerlink" title="通信需要解决的问题"></a>通信需要解决的问题</h2><ul><li>如何给其他进程发消息</li><li>如何确保通信时不访问临界区</li><li>进程间如果存在依赖关系，如何设计他们合适的运行顺序</li></ul><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>​    两个多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，就称为竞争条件<code>race condition</code></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220320200559380.png"></p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul><li>互斥<code>mutual exclusion</code><ul><li>以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作</li></ul></li><li>临界区<code>critical region</code><ul><li>对共享内存进行访问的程序片段</li></ul></li></ul><h2 id="几种解决方案"><a href="#几种解决方案" class="headerlink" title="几种解决方案"></a>几种解决方案</h2><p>无论如何都要做到</p><pre class="line-numbers language-none"><code class="language-none">!! 任意两个进程不能在同一时间都存在临界区中；!! 不能对CPU的数量和执行速度做任何的猜测和假设；!! 临界区外的进程不能阻塞其他进程的执行；!! 不能让进程在临界区外一直等待；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基于忙等待的互斥"><a href="#基于忙等待的互斥" class="headerlink" title="基于忙等待的互斥"></a>基于忙等待的互斥</h3><blockquote><p>忙等待：进程不断地读turn的值，只是他没有做任何有意义的事（等待），而且浪费了cpu的时间（忙）。故称作忙等待  busy waiting </p></blockquote><h4 id="关闭中断"><a href="#关闭中断" class="headerlink" title="关闭中断"></a>关闭中断</h4><blockquote><p> 进程进入临界区后先关中断，离开前开中断。</p></blockquote><p>评价：</p><ul><li>不应将关中断的权力交给用户</li><li>中断响应关闭后，系统就完全失去控制了</li><li>多处理的系统中，该方案无效，因为其他CPU也会响应中断的。</li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220322163350263.png"></p><h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>一种<em>软件解决方案</em></p><blockquote><p>定义一个变量，当作一把锁，进临界区后锁上，出临界区开锁</p></blockquote><p>评价：</p><ul><li>有纰漏，如果某进程检查锁，发现是开的，但在它准备进入时且还没上锁时，另一个进程进行检测，发现锁是开的，这样就会造成冲突。</li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220322163350263.png"></p><h4 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h4><blockquote><p>几个进程轮换进入某一临界区，且顺序不能紊乱</p></blockquote><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220320203026374.png" alt="伪代码"></p><p>评价：</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220320203830167.png"></p><ul><li>轮流进入临界区在一个进程比另一个进程慢很多的情况下不适用</li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220322163350263.png"></p><h4 id="Peterson解决方案"><a href="#Peterson解决方案" class="headerlink" title="Peterson解决方案"></a>Peterson解决方案</h4><p>​    基于<code>Dekker</code> 算法（将轮换法和锁变量以及警告变量的思想相结合）Dijkstra 提出了新的解决方案，<strong>它是有效的，可用的，且应用广泛。</strong>😍</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220320204809033.png" alt="算法伪代码"></p><h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>​    这是一种需要硬件支持的方法</p><ul><li><strong>优点</strong><ul><li>适用于任意数目的进程，在单处理器或多处理器上</li><li>简单，容易验证其正确性</li><li>可以支持进程内存在多个临界区，只需为每个临界区设立一个布尔变量</li></ul></li><li><strong>缺点</strong><ul><li>等待要耗费CPU时间，不能实现”让权等待”</li><li>可能”饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li><li>可能死锁</li></ul></li></ul><blockquote><p>Peterson 和 TSL 都是正确的解决方法，但都存在忙等待的缺点，浪费 CPU 的资源，进程的优先级也有区别。因此我们引入新的解决方案。</p></blockquote><h3 id="睡眠与唤醒-生产者消费者"><a href="#睡眠与唤醒-生产者消费者" class="headerlink" title="睡眠与唤醒|生产者消费者"></a>睡眠与唤醒|生产者消费者</h3><p>睡眠<code>sleep</code>、唤醒<code>wakeup</code></p><p>利用这两个系统调用，我们引入<strong>生产者消费者</strong>问题</p><ul><li>“生产者”进程不断写入，而”消费者”进程不断读出；</li><li>共享缓冲区共有N个；</li><li>任何时刻只能有一个进程可对共享缓冲区进行操作。</li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220321172118498.png"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220321172950133.png" alt="实现代码"></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​        <code>E.W.Dijkstra</code>在 1965 年提出，它使用一个整型变量来累计唤醒次数，引入一种新的变量类型，称作信号量<code>semaphore</code>。</p><p>​        <font color="green" size="5" face="黑体">信号量被广泛使用！</font></p><ul><li>信号量为0<ul><li>表示没有积累下的唤醒操作</li></ul></li><li>信号量为正值<ul><li>表示有一个或多个积累下的唤醒操作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220321181542834.png" alt="原语"></p><p>有这样两个<code>原子操作</code>：</p><ul><li><code>down</code>相当于 sleep 操作</li><li><code>up</code>相当于 wakeup 操作</li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/ApplicationFrameHost_q5keEGrUr2.png" alt="信号量解决生产者消费者问题"></p><p>​    信号量<code>mutex</code>用于互斥，用于保证任一时刻只有一个进程读写缓冲区和相关变量。</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是对信号量的一种封装，提供一种实现互斥的简便途径。</p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220321182555079.png"><p>来自知乎陈龙的解释👉<a href="https://www.zhihu.com/question/30641734/answer/378435042">链接</a></p><blockquote><p>打一个相对形象的比喻：</p><p>人们到一家叫做计算机的银行取钱，这个银行里面就一个空窗口。最早之前，每个人需要从这个窗口爬进去取钱。</p><p>这里，银行里面每一个需要取钱的人看作进程，而银行里面的钱可以看做计算机的共享资源，一般是硬件设备或一群共享变量。</p><p>每个人都向窗口拥挤，场面混乱不堪。</p><p>后面计算机银行不断改进，发明了一种叫ATM的机器（管程），ATM（管程）封装了钱和对外开放了一些存取钱的操作。</p><p>这样一来，ATM（管程）在计算机银行的钱和客户之间担任了中介服务的角色。</p><p>在一个相对封闭的屋子里面，一次只能服务一个人（让进程互斥使用）。ATM屋子里面有人的时候，其他需要依次排队使用。</p><p>一个人（进程）在ATM使用的时间太长也不行，所以需要一个条件变量（condition）来约束他。条件变量可以让一个线程等待时让另一线程进入管程，这样可以有效防止死锁。</p></blockquote><p>管程使并行编程比用信号量更容易保证正确性。</p><p><font color="red">弊端：</font></p><ul><li>支持管程的编程语言太少，而且它要求编译器的支持</li></ul><p>所以，我们需要新的解决办法！</p><h1 id="经典-IPC-问题"><a href="#经典-IPC-问题" class="headerlink" title="经典 IPC 问题"></a>经典 IPC 问题</h1><h2 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h2><p>是一类<font color="green">多进程访问有限资源</font>的问题</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220321194612142.png" alt="一种错误的解法"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220321194255017.png" alt="解决的代码"></p><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><p>是一类<font color="green">数据库的访问模型</font></p><h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="几种分类"><a href="#几种分类" class="headerlink" title="几种分类"></a>几种分类</h2><h3 id="按调度层次"><a href="#按调度层次" class="headerlink" title="按调度层次"></a>按调度层次</h3><ul><li>宏观调度<ul><li>作业</li></ul></li><li>中级调度<ul><li>内外存交换</li></ul></li><li>微观调度<ul><li>进程或线程</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220322130630989.png"></p><h3 id="按时间周期"><a href="#按时间周期" class="headerlink" title="按时间周期"></a>按时间周期</h3><ul><li>长期<ul><li>进程投入进程缓冲池</li></ul></li><li>中期<ul><li>将进程的部分或全部加载到内存中</li></ul></li><li>短期<ul><li>选择某个进程在处理机上执行</li></ul></li></ul><h3 id="按-OS-分类"><a href="#按-OS-分类" class="headerlink" title="按 OS 分类"></a>按 OS 分类</h3><ul><li>批处理<ul><li>使用与大中型主机几种计算</li></ul></li><li>分时、实时<ul><li>没有专门的作业调度</li></ul></li><li>多处理机</li></ul><h2 id="调度的性能准则"><a href="#调度的性能准则" class="headerlink" title="调度的性能准则"></a>调度的性能准则</h2><h3 id="面向用户"><a href="#面向用户" class="headerlink" title="面向用户"></a>面向用户</h3><ul><li>周转时间</li><li>相应时间</li><li>截止时间</li><li>公平性</li><li>优先级</li></ul><h3 id="面向系统"><a href="#面向系统" class="headerlink" title="面向系统"></a>面向系统</h3><ul><li>吞吐量</li><li>处理机利用率</li><li>各种设备的均衡利用</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>易于实现</li><li>执行开销比</li></ul><p><font color="green">合适的调度算法需要遵守的原则：</font></p><ol><li>公平——每个进程有合理的 CPU 份额</li><li>有效——CPU 百分百忙碌</li><li>响应时间——使得交互用户的响应时间尽可能短</li><li>周转时间——使批处理用户等待的输出时间尽可能短</li><li>吞吐量——使每小时处理的作业数最多</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>FCFS <code>First Come First Serve</code></p><ul><li>有利于长作业不利于短作业</li><li>有利于 CPU 繁忙的作业，不利于 I/O 繁忙的作业</li></ul><h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p><code>Round Robin</code></p><p>其基本思路是通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率；</p><h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>本算法平衡各进程对响应时间的要求。适用于作业调度和进程调度，可分成静态和动态两种方式</p><h4 id="静态优先级调度"><a href="#静态优先级调度" class="headerlink" title="静态优先级调度"></a>静态优先级调度</h4><p>创建进程时就确定优先级，直到进程终止前都不改变。通常是一个整数</p><h4 id="动态优先级调度"><a href="#动态优先级调度" class="headerlink" title="动态优先级调度"></a>动态优先级调度</h4><p>在创建进程时赋予其优先级，但在进程运行过程中可以自动改变，以便获得更好的调度性能。</p><h3 id="多重队列"><a href="#多重队列" class="headerlink" title="多重队列"></a>多重队列</h3><p>引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标。</p><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><p>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢正在执行中的作业,只对队列中就绪的进程进行调整。</p><p>算法优点：</p><ul><li><p>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</p></li><li><p>提高系统的吞吐量；</p></li></ul><p>算法缺点：</p><ul><li><p>对长作业非常不利，可能长时间得不到执行；</p></li><li><p>未能依据作业的紧迫程度来划分执行的优先级；</p></li><li><p>难以准确估计作业（进程）的执行时间，从而影响调度性能。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记_01</title>
      <link href="/2022/03/02/os01-introduction/"/>
      <url>/2022/03/02/os01-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列笔记参考书籍为 Tanenbaum 的 Operating Systems Design and Implementation ,3th edition.</p><blockquote><p>Tanenbaum 是荷兰的一名计算机科学家，20世纪80年代，他教授操作系统这门课，由于 UNIX 的版权原因，许多大学的操作系统课程不能再使用 UNIX 的源码进行剖析教学，转而教授更偏向理论层面的内容，而这些内容往往触碰不到操作系统这门课的核心之处。出于教学的需要，Tanenbaum 从头开始，开发出了一个小巧、完整、开源、UNIX 兼容的操作系统 <strong>MINIX</strong>，MINIX 的诞生也推动了 Linux 的产生！</p></blockquote><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220302202457342.png" alt="现代计算机的组成"></p><ul><li>物理设备<ul><li>组成计算机的硬件部分</li></ul></li><li>微体系结构<ul><li>各物理设备被组成一个个<strong>功能单元</strong></li></ul></li><li>机器语言<ul><li>用于操作硬件的指令集，50~300条，如数据传送、数值比较等</li></ul></li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>​        所谓操作系统，一般是指在<strong>内核态(Kernel Mode)</strong> 或<strong>管态 (Supervisor mode)</strong> 下运行的软件，它受到硬件的保护！</p><h2 id="Kernel-？"><a href="#Kernel-？" class="headerlink" title="Kernel ？"></a>Kernel ？</h2><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/Kernel_Layout.svg" alt="Kernel_Layout"></p><p>​        上图很清楚的为我们解释了什么叫做 Kernel ，在操作系统中，Kernel 是硬件与软件的中介，它将应用与硬件分割开来，保证了硬件的统一调用，将底层的复杂性封装起来，同时提供接口供应用层使用。</p><p>​        MINIX3 的内核是微内核，这个我们后面再谈。</p><h2 id="操作系统是拓展机"><a href="#操作系统是拓展机" class="headerlink" title="操作系统是拓展机"></a>操作系统是拓展机</h2><p>​        它将硬件细节与程序员隔离开来，对于每一个硬件，操作系统都提供了一种简单、好用的接口。它为用户提供一台等价的拓展计算机，更易编程，为用户提供各种服务，用户程序可以通过系统调用<code>System Call</code>来使用这些服务。</p><h2 id="操作系统是资源管理器"><a href="#操作系统是资源管理器" class="headerlink" title="操作系统是资源管理器"></a>操作系统是资源管理器</h2><p>​        现代计算机包括诸如 CPU、GPU、存储器、I/O设备、网络接口、打印机等其他设备，它是一个复杂系统的管理者，负责合理高效地分配系统资源。</p><ul><li>共享<ul><li>时间上</li><li>空间上</li></ul></li></ul><h1 id="操作系统发展史"><a href="#操作系统发展史" class="headerlink" title="操作系统发展史"></a>操作系统发展史</h1><h2 id="第一代计算机-1950-真空管和插接板"><a href="#第一代计算机-1950-真空管和插接板" class="headerlink" title="第一代计算机 1950 真空管和插接板"></a>第一代计算机 1950 真空管和插接板</h2><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220302210018053.png" alt="ENIAC"></p><p>​        这个时代没有编程语言，只有机器语言，更没有操作系统，用插接板来控制计算机的基本操作以及编程。</p><blockquote><p>主要用于计算正弦余弦函数表</p></blockquote><h2 id="第二代计算机-1960-晶体管与批处理"><a href="#第二代计算机-1960-晶体管与批处理" class="headerlink" title="第二代计算机 1960 晶体管与批处理"></a>第二代计算机 1960 晶体管与批处理</h2><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/IBM7094.jpg" alt="IBM7094"></p><p>​        有了晶体管，故障率明显降低，但计算机（那时多称主机 mainframe），十分昂贵，高达几百万美元一台，这就显得机时的宝贵，也就促成了批处理系统的诞生，这个时代的人们多采用打孔卡片与计算机进行通讯，通过卡片传入数据与程序。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220302211113810.png" alt="批处理系统"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ JOB,最大运行时间（minutes),收费员姓名$ FORTRAN (提示系统装入该语言的编译器)//////程序员编写的FORTRAN源程序//////$LOAD$RUN//////数据//////$END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220302211522984.png" alt="工作流程"></p><blockquote><p>主要用于求解偏微分方程</p></blockquote><p>​        此时已经出现操作系统，FMS（FORTRAN Monitor System)、IBSYS(IBM为7096机开发的操作系统）等</p><h2 id="第三代计算机-1970-集成电路和多道程序"><a href="#第三代计算机-1970-集成电路和多道程序" class="headerlink" title="第三代计算机 1970 集成电路和多道程序"></a>第三代计算机 1970 集成电路和多道程序</h2><p>​        为了减少机时的浪费，将内存分割为多块，存入不同的任务。</p><p>​        假脱机技术SPOOLING(<strong>S</strong>imultaneous <strong>P</strong>eripheral <strong>O</strong>perations <strong>O</strong>n-line)</p><p>的产生使得不再需要一台专门的机器读取磁带了，在现代，SPOOLING也应用广泛，比如打印机的使用就采用了SPOOLING,在计算机后台往往有一个程序<code>Spooler</code>管理打印机</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220302213710950.png" alt="Windows后台的Spooler进程"></p><blockquote><p>Spooling is a combination of <a href="https://en.wikipedia.org/wiki/Data_buffer">buffering</a> and <a href="https://en.wikipedia.org/wiki/Queue_(data_structure)">queueing</a>.</p></blockquote><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>​        为了弥补批处理系统的缺陷，对CPU进行分时处理，每个用户都有一个联机的终端，看起来就好像是每个人独占一台计算机一样，实际上只有一台主机进行处理任务，每台终端的任务会被CPU分配一段时间间断执行，CPU在多个任务中切换运算。</p><blockquote><p>Compatible Time-Sharing System (CTSS) MIT开发，第一个真正的分时系统</p></blockquote><h3 id="MULTICS"><a href="#MULTICS" class="headerlink" title="MULTICS"></a>MULTICS</h3><p>​    <em>Multics</em> (“Multiplexed Information and Computing Service”) ，MIT, Bell Lab, General Electric(GE)，共同开发的一种<code>公用计算服务系统</code>，想像电力系统一样即插即用。但这个项目最终失败了，不过它带给计算机领域的贡献是巨大的。</p><p><strong>它催生了 UNIX 和 C 语言的产生</strong></p><h3 id="小型机的崛起"><a href="#小型机的崛起" class="headerlink" title="小型机的崛起"></a>小型机的崛起</h3><p>​        DEC公司的 PDP 系列大获成功</p><p>​        贝尔实验室的<code>Ken Thompson</code>在一台<code>PDP-7</code>中开发了一种简化版的<code>MULTICS</code>，为单用户打造，这也是<code>UNIX</code>的源头</p><p>​        UNIX 又衍生出两个分支</p><ul><li>AT&amp;T <code>System V</code></li><li>University of California, Berkeley <ul><li><code>BSD</code>(Berkeley Software Distribution)</li></ul></li></ul><p>由于系统版本过多，IEEE制定了最小接口标准<code>POSIX</code></p><h2 id="第四代计算机-1980-个人计算机和微处理器"><a href="#第四代计算机-1980-个人计算机和微处理器" class="headerlink" title="第四代计算机 1980 个人计算机和微处理器"></a>第四代计算机 1980 个人计算机和微处理器</h2><p>​        初期 Intel 的8086微处理器和<code>CP/M</code>操作系统共同占有市场，微软早期销售CP/M卡和Basic解释器。</p><p>​        随着16位处理器的出现，微软将 DOS 和 Basic 解释器打包并改进得到了<code>MS-DOS</code>，这是微软的第一个操作系统。</p><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><blockquote><p>Graphical user interface 图形化用户界面</p></blockquote><ul><li>斯坦福的 Doug Engelbart 发明了它</li><li>乔布斯 Macintosh 采用了GUI界面</li></ul><h3 id="——当代"><a href="#——当代" class="headerlink" title="——当代"></a>——当代</h3><p>Mac OS X 基于<code>Berkeley UNIX</code></p><p>Window NT 是 当前 Window 系统的源头</p><h1 id="MINIX"><a href="#MINIX" class="headerlink" title="MINIX"></a>MINIX</h1><ul><li>微内核，内核只有几千行代码</li><li>模块化</li></ul><p>Linux 正是基于 MINIX 开发出来的</p><h2 id="挂装-mount"><a href="#挂装-mount" class="headerlink" title="挂装 mount"></a>挂装 mount</h2><p>​        在 MINIX 中，可移动存储设备往往需要通过挂装的方式与文件系统合并，从而 达成访问的目的。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/ApplicationFrameHost_0da5ZNJa31.png"></p><h2 id="设备文件-special-files"><a href="#设备文件-special-files" class="headerlink" title="设备文件 special files"></a>设备文件 special files</h2><p>​        由于 MINIX 采用微内核，因此设备被特化为一种特殊形式的文件，设备文件又分为两种。</p><ul><li>块设备文件 Block special file<ul><li>磁盘</li></ul></li><li>字符设备文件 character special file<ul><li>打印机</li></ul></li></ul><h2 id="文件保护机制"><a href="#文件保护机制" class="headerlink" title="文件保护机制"></a>文件保护机制</h2><ul><li>rwx r– r–  ↔ r w x   r - -   r - -<ul><li>r: read</li><li>w: write</li><li>x: execute(file)   search( folder, directory )</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303085937921.png"></p><blockquote><p><strong>一个文件有的权限部分共有三组</strong> <strong>rwx</strong> <strong>rwx</strong> <strong>rwx</strong><br> 每一位只有两种可能: 一种是有这个位的权限，另一种是没有这个位的权限，所以可以用二进制表示有和没有，但为简化，所以chmod后面需是8进制数，每个数代表属主属组和其它，<code>r为4，w为2, x为1 -为0,</code> 将每组中的三个要素的数字加到一起就是这个组的权限代数，每个权限与进制数的关系如下 rwx rwx rwx<br> 421 421 421 也就是4+2+1=7 4+2+1=7 4+2+1=7 所以最大权限是777<br> 又如下面的权限就是 660<br> rw- rw- —<br> 420 420 000     4+2=6,4+2=6,0<br> 再如下面的权限是 526<br> r-x -w- rw-<br> 401 020 420  </p><p>​    也就是说想把一个文件的权限变成以上情况则输入chmod 526 filename ;  0751呢<br>但在此要说明一下，只是运行<em>chmod</em> 的用户对此文件有<strong>w</strong>的权限才能重新设置文件权限。<br> root可设置任何文件的权限.</p></blockquote><h2 id="系统调用-System-Call"><a href="#系统调用-System-Call" class="headerlink" title="系统调用 System Call"></a>系统调用 System Call</h2><p>MINIX的系统调用如下图</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303125622421.png"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303125645196.png"></p><p><code>Ctrl+C</code>==<code>SIGINT</code>中断信号</p><p><code>Ctrl+\</code>==<code>SIGQUIT</code>产生退出信号并强制进行内核映像转储</p><p><code>Ctrl+S</code>停止输出，<code>Ctrl+Q</code>恢复终端输出</p><p><code>Ctrl+D</code>文件结束</p><h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><code>一锅粥</code>，是各类函数的集合，没有隐藏，所有函数都是相互可见的。</p><blockquote><p>访问操作系统提供的服务流程是：</p><p>​                先把参数放入指定位置（如栈），然后执行<code>TRAP</code>指令，即内核调用<code>Kernel Call</code></p></blockquote><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303173128085.png"></p><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p>组织成层次结构，层层封装，向上提供接口</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303201333799.png"></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>此虚拟机非彼虚拟机</p><p>核心是一个虚拟机监控程序</p><p>裸机硬件的精确拷贝</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303201354792.png"></p><h2 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h2><p>省去映射层的虚拟机，划分磁盘块给不同的虚拟机运行</p><h2 id="客户-服务器结构"><a href="#客户-服务器结构" class="headerlink" title="客户-服务器结构"></a>客户-服务器结构</h2><p>适用于分布式系统</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303201430393.png"></p><p>内核只处理客户与服务器间的通信</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220303201417706.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的第一台Mac何必是Mac？</title>
      <link href="/2022/02/24/macos-xu-ni-ji/"/>
      <url>/2022/02/24/macos-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        前两天上操作系统课，老师给我们布置了一个作业——“在电脑上装上虚拟机，自己运行一下 Ubuntu。” 我操作了一下，成功安装上了 Ubuntu。于是我就想顺便装上 MacOS 体验一下程序员人手一个的 Mac 系统。这便催生了这篇文章的产生，希望对你有所帮助。</p><p>​        为了这篇教程，我花了很大的精力，尝试了常见的<code>VMware</code>&amp;<code>VisualBox</code>两大主流虚拟机，查询了中英文资料，最终成功安装。（PS. 折戟 VisualBox 十次、VMware 配环境三次…）</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/MacOS_Catalina_Desktop.png" alt="MacOS_Catalina_Desktop"></p><h1 id="你需要准备"><a href="#你需要准备" class="headerlink" title="你需要准备"></a>你需要准备</h1><ol><li><p><a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">VMware安装包</a></p></li><li><p><a href="">MacOS镜像 ISO 文件</a></p><blockquote><p>在我的网盘里我提供了<code>Catalina</code>和<code>Big Sur</code>两个版本的 ISO 文件</p></blockquote></li><li><p>VMware激活码</p><p>关于激活码，百度直接搜就有一大把，而且基本上都是有效的。这里就给各位附上三条：</p><blockquote><p>   ZF3R0-FHED2-M80TY-8QYGC-NPKYF<br>   YF390-0HF8P-M81RQ-2DXQE-M2UT6<br>   ZF71R-DMX85-08DQY-8YMNC-PPHV8</p></blockquote></li><li><p><a href="https://github.com/DrDonk/unlocker/releases">VMware_UnLocker</a></p></li></ol><p>当然，如果你想一步到位的话，我已经将所有需要的文件打包上传到百度云盘里了，各位可直接点击链接<a href="https://pan.baidu.com/s/1l7MVW3mUDPSzbnliPBRaqw?pwd=1304">下载</a></p><p>提取码：1304</p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="1、安装VMware"><a href="#1、安装VMware" class="headerlink" title="1、安装VMware"></a>1、安装VMware</h2><p>运行安装程序，程序自动安装，最后一步使用激活码激活。</p><h2 id="2、停止-VMware-Workstation-Pro-16-的系统服务"><a href="#2、停止-VMware-Workstation-Pro-16-的系统服务" class="headerlink" title="2、停止 VMware Workstation Pro 16 的系统服务"></a>2、停止 VMware Workstation Pro 16 的系统服务</h2><p>（1）打开任务管理器，进入“服务”版块；</p><p>（2）从下至上，按右键依次停止如图所示与 VM 相关的4个服务。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224150623344.png" alt="停止VM服务"></p><h2 id="3、用-Unlocker-让-VMware-支持安装-macOS-系统"><a href="#3、用-Unlocker-让-VMware-支持安装-macOS-系统" class="headerlink" title="3、用 Unlocker 让 VMware 支持安装 macOS 系统"></a>3、用 Unlocker 让 VMware 支持安装 macOS 系统</h2><p>（1）到 <a href="https://github.com/DrDonk/unlocker/releases">https://github.com/DrDonk/unlocker/releases</a> 下载最新的 Unlocker。</p><p>（2）解压出文件夹之后，找到<code>win-install.cmd</code>，按右键以管理员身份运行。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224132550731.png"></p><p>​        如何确认这一步成功了呢？一种方法是看你的小黑窗里面的一长串英语有没有报错，另一种方法比较简单：看运行完<code>win-install.cmd</code>文件后有没有在 <code>unlocker</code>的文件夹里多出一个<code> backup</code>文件夹（见上一张图），以及你的<code>VMware Workstation</code>文件夹里有没有多出 <code>darwin.iso</code> 和 <code>darwinPre15.iso</code>这两个文件（如下图所示）。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224132846085.png" alt="在Everything中查找"></p><p>（这里推荐一款搜索工具<code>Everything</code>拥有远超 Windows 默认搜索的速度！<a href="https://github.com/Wox-launcher/Wox/releases/tag/v1.3.524">点击我下载</a>）</p><h2 id="4、创建虚拟机"><a href="#4、创建虚拟机" class="headerlink" title="4、创建虚拟机"></a>4、创建虚拟机</h2><p>按照与第2步相反的顺序启动VM相关的4个服务</p><p>然后启动 VMware Workstation Pro 16，创建新的虚拟机。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133336529.png"></p><p>找到之前下载的苹果系统镜像文件，打开。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133410517.png"></p><p>选择系统</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133440357.png"></p><p>找一个大一点的磁盘存虚拟机文件</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133501865.png"></p><p> 继续，最大磁盘100G更宽裕点</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133529741.png"></p><p>默认的硬件配置差不多够了，后期还可以修改的。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133613717.png"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224133725154.png" alt="后期在这里改配置"></p><h2 id="5、AMD-CPU再做最后一步设置"><a href="#5、AMD-CPU再做最后一步设置" class="headerlink" title="5、AMD CPU再做最后一步设置"></a>5、AMD CPU再做最后一步设置</h2><p>在虚拟机的目录中找到<code>.vmx</code>后缀的文件，我的虚拟机命名为”mac 11”，因此该文件名为mac 11.vmx，右键编辑(可以使用 VScode 打开)。</p><p>在该文件末尾追加下列语句。</p><pre class="line-numbers language-none"><code class="language-none">smc.version = "0"cpuid.0.eax = "0000:0000:0000:0000:0000:0000:0000:1011"cpuid.0.ebx = "0111:0101:0110:1110:0110:0101:0100:0111"cpuid.0.ecx = "0110:1100:0110:0101:0111:0100:0110:1110"cpuid.0.edx = "0100:1001:0110:0101:0110:1110:0110:1001"cpuid.1.eax = "0000:0000:0000:0001:0000:0110:0111:0001"cpuid.1.ebx = "0000:0010:0000:0001:0000:1000:0000:0000"cpuid.1.ecx = "1000:0010:1001:1000:0010:0010:0000:0011"cpuid.1.edx = "0000:0111:1000:1011:1111:1011:1111:1111"featureCompat.enable = "TRUE"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、启动虚拟机"><a href="#6、启动虚拟机" class="headerlink" title="6、启动虚拟机"></a>6、启动虚拟机</h2><p>​        如果你启动虚拟机后看到苹果的 Logo 恭喜你，你离胜利不远了！</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224134529762.png" alt=" 选磁盘工具，点“继续”"></p><p>​        <img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224134619582.png" alt="抹掉磁盘"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224134648645.png" alt="自己命名，改格式，点“抹掉”"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224134715160.png" alt="抹掉后叉掉这个窗口"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224134755581.png" alt="点安装macOS、“继续”"></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224134830518.png" alt="选择之前抹掉的磁盘进行安装"></p><p>到了这一步就没有什么难度了，按照官方的引导一步一步做下去就可以了，但可能需要20分钟安装系统😶请耐心等待.</p><h3 id="Enjoy-your-MacOS😉"><a href="#Enjoy-your-MacOS😉" class="headerlink" title="Enjoy your MacOS😉"></a>Enjoy your MacOS😉</h3><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220224142433087.png" alt="MacOS"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>VisualBox 安装 MacOS 可谓困难重重… 如果你是 AMD CPU 我建议你用 VMware.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>鸣谢:</p><p><a href="https://mp.weixin.qq.com/s/eMAgVApZNt98ovbBEly6Pw">2022年最新保姆级VM16虚拟机安装macOS苹果系统教程</a></p><p><a href="https://www.jxzssy.top/article/90.html">VMware安装MacOS遇到“客户机操作系统已禁用 CPU。请关闭或重置虚拟机。”解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> VMware </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的了解字体吗？| 衬线与非衬线</title>
      <link href="/2022/02/22/chen-xian-yu-fei-chen-xian-zi-ti/"/>
      <url>/2022/02/22/chen-xian-yu-fei-chen-xian-zi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    在修改 Chrome 浏览器的字体时，我发现了有以下几个选项👇</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220222220431141.png" alt="Chrome 字体设置"></p><p>​    这其中就有<code>Sans Serif </code> 和<code>Serif</code>这两类字体，还有一个<code>宽度固定</code>，于是我想了解它们之间的具体区别和使用场景，这也就催生了这篇文章的产生，希望你阅读后会有收获😜</p><h1 id="字体划分"><a href="#字体划分" class="headerlink" title="字体划分"></a>字体划分</h1><p>​    在西方国家罗马字母阵营中，字体分为两大种类：<code>Sans Serif</code>和<code>Serif</code>，打字机体虽然也属于 Sans Serif，但由于是等宽字体，所以另外独立出<code>Monospace</code>这一种类，例如在Web中，表示代码时常常要使用等宽字体。 </p><p>​                             <img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220222221505267.png"><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220222221723241.png"></p><p>​    具体的结构归属可以参照上图👆</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>衬线(Serif):在字的笔划开始及结束的地方有额外的装饰，而且笔划的粗细会因直横的不同而有不同</p></blockquote><blockquote><p>非衬线：没有额外的装饰，笔划粗细大致差不多</p></blockquote><p>​    这类区分在汉字字体中也有所体现，下图很清晰地展示出来了衬线与非衬线之间的区别。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220222215434044.png"></p><p>​    可以看出，我们平时所用的<code>Georgia</code>、<code>Times New Roman</code>等就属于<code>Serif</code>字体，而<code>Arial</code>、<code>Tahoma</code>等则属于<code>Sans Serif</code>字体。对中文而言，同样存在这两大种类，很明显，宋体、细明体(繁体中常用)等就属于<code>Serif</code>，而黑体、幼圆等则属于<code>Sans Serif</code>。 </p><h1 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h1><p><strong>Serif 和 Sans Serif 的一般比较：</strong></p><p>　　①Serif 的字体容易辨认，因此易读性较高。反之 Sans Serif 则较醒目，但在行文阅读的情况下，Sans Serif 容易造成字母辨认的困扰，常会有来回重读及上下行错乱的情形。</p><p>　　②<strong>Serif</strong> 强调了字母笔划的开始及结束，因此<strong>较易前后连续性的辨识</strong>。 </p><p>　　③Serif 强调一个 word，而非单一的字母，反之 <strong>Sans Serif 则强调个别字母</strong>。</p><p>　　④在小字体的场合，通常 Sans Serif 比 Serif 更清晰。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220222223959444.png"></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>​            通常文章的<strong>内文、正文使用易读性较佳的 Serif 字体</strong>，这可增加易读性，而且长时间阅读下因为会以 word 为单位来阅读，较不容易疲倦。</p><p>​            <strong>标题、表格内用字则采用较醒目的 Sans Serif 字体</strong>，它需要显着、醒目，但不必长时间盯着这些字来阅读。 </p><p>　　像宣传品、海报类，为求醒目，它的短篇的段落也会采用 Sans Serif 字体。但在书籍、报刊杂志，正文有相当篇幅的情形下，则应采用 Serif 字体来减轻读者阅读上的负担。在Web设计及浏览器设置中也应遵循此原则。</p><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>​            <strong>其他的通用字体族</strong></p><p>　　印刷学中，除了 <code>serif </code>和 <code>sans-serif </code>之外，通常还有 <code>Monospace</code> 等宽字体、<code>scripts</code>手写体（比如花体）、<code>blackletter </code>铅字体（也叫 <code>gothic</code> 哥特体。严格的说，很多常用的 <code>serif</code> 字体其实是 <code>gothic</code>字体）、<code>ornamental</code> 装饰体和<code>symbol </code>符号字体（比如有名的<code>wedding123</code>）</p><p>　　<strong>Monospace 等宽字体：</strong></p><p>　　所谓的等宽字体，是指每个字符宽度都一致的字体。一个著名的例子就是 <code>Courier New </code>字体。因为字符宽度一致，所以特别容易对齐，能快速精确的定位到某行某列，因此经常用来显示代码。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220222224931325.png" alt="Courier New 字体">　　</p><p>​        Cursive书写体：相当于印刷学中的手写体。中文的华文行草就是这样的一个字体。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在显示不同内容的时候，应该根据该内容的阅读效果合理选择字体种类，达到功能性与美观性的统一。</p><p><strong>参考资料：</strong></p><p><a href="https://kb.cnblogs.com/page/192018/">Serif和Sans-serif字体的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 字体 </tag>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用PicGo+Github部署免费图床</title>
      <link href="/2022/02/13/shi-yong-picgo-github-bu-shu-tu-chuang/"/>
      <url>/2022/02/13/shi-yong-picgo-github-bu-shu-tu-chuang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>为什么需要图床？</p></blockquote><p>​    因为足够简单、方便。在编写 Markdown 文档时引用图片可以直接部署URL , 不必专门去纠结相对路径、绝对路径，不必专门找个文件夹放图片。</p><h1 id="需要提前准备的东西"><a href="#需要提前准备的东西" class="headerlink" title="需要提前准备的东西"></a>需要提前准备的东西</h1><ul><li><p>安装<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></p><blockquote><p>PicGo 是一款开源的图床工具，Typora 也对它进行了支持</p></blockquote></li><li><p>拥有一个<a href="https://github.com/">Github</a>账号</p></li></ul><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-新建-Github-仓库"><a href="#1-新建-Github-仓库" class="headerlink" title="1.新建 Github 仓库"></a>1.新建 Github 仓库</h2><p>点击github 主页右上角的 <code>+</code> 创建<code>New repository</code></p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214200934506.png" alt="新建仓库"></p><p>​    填写仓库信息，仓库得设置为 <code>Public</code> 因为后面通过客户端访问算是外部访问，因此无法访问<code>Private</code>，这样的话图片传上来之后只能存储不能显示。所以要设置为<code>Public</code>，填写好后直接点击 <code>Create repository</code> 就行了。</p><p>​    这也是Github做图床的一个劣势，隐私性低，不过一般人也不会随便把重要的图片上传到图床里，真正传入的都是博客里公开的照片，因此不用担心。</p><h2 id="2-获得-Token"><a href="#2-获得-Token" class="headerlink" title="2.获得 Token"></a>2.获得 Token</h2><h3 id="什么是-Token"><a href="#什么是-Token" class="headerlink" title="什么是 Token"></a>什么是 Token</h3><blockquote><p>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p><p>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p></blockquote><p>​    简单来说，Token 就是一串暗号，告诉 Github 使用这个暗号的人有资格访问你的仓库，并具备一定的权限。</p><h3 id="配置-Token"><a href="#配置-Token" class="headerlink" title="配置 Token"></a>配置 Token</h3><p>如图点击 Settings</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214203401076.png"></p><p>找到<code>Developer settings</code>，并进入 <code>Personal access tokens</code> 然后点击<code>Generate new token</code>，创建token；</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214212120387.png"></p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214212233490.png"></p><p>然后复制生成一串字符token，这个token 只出现一次，所以要保存一下。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214212315516.png"></p><h2 id="3-配置-PicGo"><a href="#3-配置-PicGo" class="headerlink" title="3.配置 PicGo"></a>3.配置 PicGo</h2><p>在 PicGo 图床设置中找到 Github 图床，按下图进行设置。</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214204301080.png" alt="配置PicGo"></p><p><code>jsdelivr</code>的配置格式如下</p><p><code>https://cdn.jsdelivr.net/gh/Github用户名/仓库名</code></p><h2 id="4-配置-Typora"><a href="#4-配置-Typora" class="headerlink" title="4.配置 Typora"></a>4.配置 Typora</h2><p>打开偏好设置</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214204555951.png"></p><p>按下图所示配置相关设定</p><p><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/image-20220214204645430.png" alt="配置Typora"></p><p>注意：PicGo 路径就是你安装 PicGo 的位置，选中 PicGo.exe 即可</p><p>配置完毕后点击<code>验证图片上传选项</code><br><img src="https://raw.githubusercontent.com/zhanlutuzi/imageBed/main/image/Typora_fKNbT3XizG.png" alt="配置成功"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    做完以上的步骤，你就会获得一个免费的Github图床，并且由于有<code>jsdelivr</code>的帮助，我们的图片从国内访问也会加载的非常快！</p><p>你可能会需要：</p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E9%98%BF%E9%87%8C%E4%BA%91oss">PicGo官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Typora </tag>
            
            <tag> Github </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ENVI 5.3 辐射定标时无法读取Landsat头文件并闪退的解决方案</title>
      <link href="/2022/02/13/envi-shan-tui/"/>
      <url>/2022/02/13/envi-shan-tui/</url>
      
        <content type="html"><![CDATA[<h1 id="问题详情"><a href="#问题详情" class="headerlink" title="问题详情"></a>问题详情</h1><p><img src="https://img-blog.csdnimg.cn/8923466f65964d9fbc1f2e77bd62ada6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rmb5rO45YWU5a2Q,size_14,color_FFFFFF,t_70,g_se,x_16" alt="辐射校正窗口"><br> 上图为辐射校正窗口，此时点击<code>OK</code>会出现下图<br> <img src="https://img-blog.csdnimg.cn/6e59027ee6bf4199a0209e95c208d344.png" alt="请添加图片描述"><br>此时ENVI报错，告诉我们</p><blockquote><p>无法在数据目录中找到正确的元数据</p></blockquote><h1 id="问题发现的过程"><a href="#问题发现的过程" class="headerlink" title="问题发现的过程"></a>问题发现的过程</h1><p>很多人会认为这是因为数据源有问题，但是我尝试了多组Landsat数据，发现都会出现这种错误，但是我换了台电脑这种问题就没有出现了，用的同一组数据源，说明<strong>数据源并不存在这个问题！</strong></p><p>于是我以<br><code>IDL_IDLBRIDGE Error: OBJ_NEW: IDLnaMetadata Error: Failed to find metadata in data catalog.</code>为关键词在网上搜寻，得到了以下几个思路。</p><p>下面是本人单纯记录一下自己蠢蠢找问题的过程，想看解决方案的朋友可直接跳转到教程部分。</p><h2 id="几个思路"><a href="#几个思路" class="headerlink" title="几个思路"></a>几个思路</h2><h3 id="1、数据源属于LandsatL2数据，ENVI暂不支持"><a href="#1、数据源属于LandsatL2数据，ENVI暂不支持" class="headerlink" title="1、数据源属于LandsatL2数据，ENVI暂不支持"></a>1、数据源属于LandsatL2数据，ENVI暂不支持</h3><blockquote><p>Landsat Collection2是USGS在陆地观测卫星图像上进行的第二次重要更新工作，推进了若干数据产品改进，这些改进利用了数据处理、算法开发以及数据访问和分发能力方面的最新进展。</p></blockquote><p>检查了一下发现我的属于L1数据，此项排除，如果有读者碰到这个问题，可以使用L2转换工具，可以参考这个连接:<br><code>http://blog.sina.com.cn/s/blog_764b1e9d010302tw.html</code></p><h3 id="2、某些数据对64位的支持较差"><a href="#2、某些数据对64位的支持较差" class="headerlink" title="2、某些数据对64位的支持较差"></a>2、某些数据对64位的支持较差</h3><p>我使用 ENVI 32bit 与 ENVI Classic 进行多次尝试，均以失败告终。<br>此项排除。</p><h3 id="3、安装包有误"><a href="#3、安装包有误" class="headerlink" title="3、安装包有误"></a>3、安装包有误</h3><p>有句话说得好啊</p><blockquote><p><strong>如果一次重装解决不了问题，那就两次,两次不行就三次…</strong></p></blockquote><p>我更换不同版本，不同安装位置（甚至专门分了个新硬盘区用来装ENVI)，重新安装了7次！<br>无效！！！！！<br>心好累….</p><h3 id="4、输入输出目录中有非法字符"><a href="#4、输入输出目录中有非法字符" class="headerlink" title="4、输入输出目录中有非法字符"></a>4、输入输出目录中有非法字符</h3><p>从安装目录开始排查起，到最后数据输入输出、软件根目录一切全部使用纯字母，我连 <code>_</code> 都没敢用，用驼峰命名法了…</p><p>但是依然没有解决问题，闪退依旧…</p><p>我忍不了了，此时我已经在电脑前坐了三个小时，就这样一个小问题都还没解决，我美好的周末在流逝！！！ 已经瘫在椅子上准备摆烂了，但是我这个人有点倔，这个问题解决不了就如鲠在喉，很难受。于是我坐了起来，打算给它最后一次机会。把ENVI<strong>卸载干净</strong>再重新安装。</p><p>于是我使用 Everything 查询了所有带 <code>ENVI</code> 关键词的文件，打算把它们清空，这时候我看到了一个文件，它的文件地址在我习惯了纯英文且无特殊字符的眼睛里看来是如此的突兀。<br>啊哈，终于抓到你了！<br><code>C:\Users\y'c'l\AppData\....</code><br>这是一个属于IDL的文件，而ENVI的辐射校正，正是通过IDL来实现的，这下就解释的通了，编程语言的环境目录里不能有汉字，不能有特殊符号，我这里就是因为有<code> '</code>这个符号才报错而无法运行。<br>既然问题找到了，那下面就很简单了。<br><strong>只需要修改User的名字为标准格式就可以了！</strong></p><h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><p><strong>！！！！！！！更改注册表有风险，建议先备份好！！！！！！！！！</strong></p><h2 id="1-在当前账户先把环境变量改好"><a href="#1-在当前账户先把环境变量改好" class="headerlink" title="1.在当前账户先把环境变量改好"></a>1.在当前账户先把环境变量改好</h2><p>如果不进行这项，很多应用是无法使用的，还会有其他奇奇怪怪的问题</p><ul><li><p>右击此电脑，选择属性，点击高级系统设置，进入下面的页面<img src="https://img-blog.csdnimg.cn/a94b7e1b42054d138d04db07d593c32e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rmb5rO45YWU5a2Q,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>单击环境变量<br><img src="https://img-blog.csdnimg.cn/80d722ae1455433abc20847174a01b1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rmb5rO45YWU5a2Q,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>在这一栏里把非法格式删去<br>改成你想要的名字(记住它，后面有用！！！）<br>（纯英文，数字不开头，无特殊符号）</p></li><li><p>设置完后单击确定来保存</p></li></ul><h2 id="2-进入Administrator账户"><a href="#2-进入Administrator账户" class="headerlink" title="2.进入Administrator账户"></a>2.进入Administrator账户</h2><p>先以管理员模式启动命令提示符（Win+X组合键后就能看到），输入</p><p><code>net user administrator /active:yes</code><br><img src="https://img-blog.csdnimg.cn/1115fec06711480ea2f9dabdc998a414.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rmb5rO45YWU5a2Q,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>注销当前账户，进入Administrator账户<br><img src="https://img-blog.csdnimg.cn/91d4614f2bbd4133802b9eb72aa7da7f.png" alt="在这里插入图片描述"><br><strong>2021.12.27更新，其实做到这一步就行了，你可以直接在Administrator的账户下运行ENVI,这样是绝对不会有任何奇奇怪怪的问题的，建议运行专业软件就在Administrator账户里进行</strong></p><h2 id="3-打开注册表"><a href="#3-打开注册表" class="headerlink" title="3. 打开注册表"></a>3. 打开注册表</h2><p>按住键盘的[win+R]，输入regedit，确定<br><img src="https://img-blog.csdnimg.cn/b5938dc67d6a4a1f819c7fd58c6dfeda.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rmb5rO45YWU5a2Q,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>跳转到<br><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</code>目录下方<img src="https://img-blog.csdnimg.cn/035cfff055644301845b3c1b20e31868.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rmb5rO45YWU5a2Q,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/55f0998c8ccd4e2dbed987429f2c7476.png" alt="在这里插入图片描述"></p><p>将此项修改为<strong>环境变量里你设置的那一个</strong><br>注意：只改最后一项，即图中 “ycl” 所处的位置.</p><p>完成改变后单击确定，并关闭注册表。</p><h2 id="4-修改用户文件名"><a href="#4-修改用户文件名" class="headerlink" title="4.修改用户文件名"></a>4.修改用户文件名</h2><p>在<code>C:\Users</code>目录下，找到你要修改的那个文件夹<br>重命名它为<strong>环境变量里你设置的那一个</strong></p><p>保存，重新启动就可以啦！</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这是我第一次写CSDN,这个问题让我苦恼了很久，在搜索引擎里搜不到解决的方法，于是我就想写这样一篇文章，能够帮助到遇到这个问题和我一样束手无策的朋友们！<br><strong>我们都站在前人的肩膀上，这个坑我先替你们踩啦！</strong></p><p>朋友们，答应我，以后买了新的电脑，一定要设置标准格式的用户名，避免这些恼人的问题！</p><p><strong>标准格式</strong></p><ul><li><strong>纯字母</strong></li><li><strong>无特殊符号</strong></li><li><strong>不要以数字开头</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ENVI </tag>
            
            <tag> GIS </tag>
            
            <tag> 遥感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章属性</title>
      <link href="/2022/02/13/hexo-wen-zhang-shu-xing/"/>
      <url>/2022/02/13/hexo-wen-zhang-shu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><pre class="line-numbers language-none"><code class="language-none">本文为转载，一切著作权归原作者所有！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来源：</p><blockquote><p><a href="https://tbfungeek.github.io/2016/02/27/Hexo-%E6%96%87%E7%AB%A0%E5%B1%9E%E6%80%A7/">Hexo文章属性</a></p></blockquote><hr><p>之前介绍使用hexo new 的时候可以带一个参数layout，那么这个layout指的是什么呢？<br>它其实是在scaffolds文件夹下的*.md<em>，默认情况下有</em>draft.md* <em>page.md</em> <em>post.md</em><br>如果没有指定的话它会默认使用<em>post.md</em> ，这个属性可以在根目录下的_config 文件中进行配置：</p><blockquote><p>default_layout: post 配置默认的layout</p></blockquote><p>同时我们也可以看到当你hexo new 的时候产生的md文件中会默认产生一些内容，这个内容就是上述介绍的<em>draft.md</em> <em>page.md</em> <em>post.md</em> 所指定的，比如下面是我自己定制的<em>post.md</em>布局：</p><pre class="line-numbers language-none"><code class="language-none">title: {{ title }}date: {{ date }}tags:categories:description:---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些比较常见，介绍如下：</p><pre class="line-numbers language-none"><code class="language-none">title: postName           文章标题date: 2013-12-02 15:30:16 文章编写的时间，这里可以随意修改categories:               文章分类目录，可以为空tags:                     文章标签，可空，多标签请用格式[tag1,tag2,tag3]description:              对本页的描述，相当于是一个简介，如果这个定义了，就会在首页中出现这里的内容而不会出现整个文章详细内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这里需要注意的是每个属性冒号后面都应该有个空格，然后再加属性值。并且一定要注意最后的三个下划线，否则文章的内容就不会被显示出来。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2022/02/13/hexo-bo-ke-da-jian/"/>
      <url>/2022/02/13/hexo-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><pre class="line-numbers language-none"><code class="language-none">本文为转载，一切著作权归原作者所有！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来源：</p><blockquote><p><a href="https://developer.aliyun.com/article/789080?spm=a2c6h.13262185.0.0.4a81a2b8cVIurx">【Hexo博客搭建】将其部署到GitHub Pages（一）：前期要做哪些准备？</a></p><p><a href="https://developer.aliyun.com/article/789233?spm=a2c6h.13262185.0.0.4a81a2b8cVIurx#slide-6">【Hexo博客搭建】将其部署到GitHub Pages（二）：如何初始化并部署？</a></p><p><a href="https://developer.aliyun.com/article/789409?spm=a2c6h.13262185.0.0.4a81a2b8cVIurx#slide-2">【Hexo博客搭建】将其部署到GitHub Pages（三）：怎么写作以及更新？</a></p></blockquote><p>原作者：<a href="https://developer.aliyun.com/profile/pl66tdtmit75e?spm=a2c6h.12873639.0.0.22ca20c0Luq8GX">百里飞洋</a> </p><hr><p><strong>简介：</strong> 本系列文章属于半笔记半教程的零基础小白入门文，教你将 Hexo 部署到 GitHub Pages 的前期需要做哪些准备，跟着此系列文章最终可以获得自己的静态博客网站。流程很长，分成不同的篇幅，此为本系列的第一篇。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每当在各种大佬群里划水的时候，身为菜鸡，总是很羡慕他们拥有自己的域名和博客。但由于还是学生党，买个域名或者租个云服务器其实也并不是很急迫的事情（主要我是怕买了之后不会用，在那一边闲着haha~），于是自己花了一天时间查找翻阅各种教程动手操作了一番，将 Hexo 部署到了 GitHub Pages，建立了自己的第一个（在某种意义上）真正属于自己的博客网站。本篇文章属于半笔记半教程的零基础小白入门文，教你将 Hexo 部署到了 GitHub Pages，从而获得自己的静态博客网站。</p><blockquote><p>【注意】：本文纯属才疏尚浅的我以笔记的形式进行的记录，很多知识其实我也不是太懂，可能存在理解偏差和错误，来学习的朋友们请自己甄别，路过的大神们也别喷我哈哈哈，有什么建议和问题可以评论提出或者其它方式联系我。我会尽可能保持更新该文章所使用到的技术和做法，并随时接受勘误。</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="一、了解并创建GitHub账号和仓库"><a href="#一、了解并创建GitHub账号和仓库" class="headerlink" title="一、了解并创建GitHub账号和仓库"></a>一、了解并创建GitHub账号和仓库</h2><p>GitHub是一个面向开源及私有软件项目的托管平台，也是世界上最大的代码托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。GitHub中文社区,是国内领先的开源社区,是一个可以发现优质开源项目的地方。</p><blockquote><p>由于程序员大多是男性，GitHub又被戏谑地调侃成全球最大同性交友网站”Gayhub”，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈……咳咳，说多了</p></blockquote><h3 id="1-注册GitHub账号"><a href="#1-注册GitHub账号" class="headerlink" title="1. 注册GitHub账号"></a>1. 注册GitHub账号</h3><p>虽然都是英文，但不必畏惧，也并不会造成使用障碍，只要记得最常用的选项含义即可，以及善用浏览器的网页翻译功能和手头的翻译软件。</p><blockquote><p>注意：注册时的英文用户名将成为你可以使用的免费域名前缀。</p></blockquote><p>注册流程非常简单，这里不再赘述。</p><h3 id="2-在-GitHub-上创建一个新的项目"><a href="#2-在-GitHub-上创建一个新的项目" class="headerlink" title="2. 在 GitHub 上创建一个新的项目"></a>2. 在 GitHub 上创建一个新的项目</h3><p>单击 右上角【+】- New Repository 新建项目。（以下简称仓库）</p><p>然后填写项目信息。</p><p>仓库的名字格式应为：<code>你的用户名.github.io</code></p><blockquote><p>为什么必须这个作为仓库名？</p><p>因为这是GitHub Pages 服务的命名规范，同时它也将成为你的专属域名。</p><p>当然，你也可以购置自己的专属域名并用它来提供内容。</p></blockquote><p>比如我的用户名是Barry-Flynn，那么我的仓库就叫：<code>Barry-Flynn.github.io</code></p><p>(全部小写更好，有大写也没事，除了大小写切换有一丢丢麻烦外没有区别）</p><p>在description一栏填写简介，随便填填，比如我填的是：<code>百里飞洋的个人空间</code></p><p>然后选择 Public。</p><p>最后勾选 Initialize the repository with a README。</p><blockquote><p>此步的作用是用一个 README.md 对这个仓库进行初始化</p></blockquote><p>完成后点击下面的 Create Repository。</p><h2 id="二、安装-VS-Code"><a href="#二、安装-VS-Code" class="headerlink" title="二、安装 VS Code"></a>二、安装 VS Code</h2><p>在安装Git之前，我建议先安装 VS Code。因为安装 Git Bash 时，可以设置 VS Code 作为默认编辑器。Visual Studio Code，简称 VS Code。目前最为强大易用的编辑器，轻量且快速。<del>（宇宙第一编辑器哈哈哈）</del></p><blockquote><p>注意：它并不是我们常常听到的 VS，VS 常常指的是 Visual Studio，是一个功能强大的 IDE（集成开发环境），体积要比 VS Code 都要大上一个量级。</p></blockquote><p>对于它的安装，直接搜官网下载就行了，免费的，不再赘述。</p><h2 id="三、安装-Git"><a href="#三、安装-Git" class="headerlink" title="三、安装 Git"></a>三、安装 Git</h2><p>Git 是一个开源的分布式版本控制系统，由 Linus Torvalds（同时也是 Linux 的作者）为了管理 Linux 开发而开发。类似的工具还有：SVN。但始终更推荐 Git，因为它功能更为强大且它的背后还有更强大的生态：GitHub。</p><p>你可以直接去官网下载Git并安装，如果国内网速太慢可以“科学上网”或者从其他平台下载。MacOS 用户可以下载官网的安装包进行安装，也可以直接安装 App Store 的 Xcode（附带会安装 Git，但是比较大）。安装时一路next到底就行了，也可以在网上找教程，我不再多说。</p><h2 id="四、安装-Node-js"><a href="#四、安装-Node-js" class="headerlink" title="四、安装 Node.js"></a>四、安装 Node.js</h2><p>何为Node.js ？Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p><blockquote><p>对的，看到这个解释我其实也一脸懵，但不妨碍我们用它，想进一步了解的朋友们可以去官网浏览官方文档。</p></blockquote><p>建议下载长期支持版，而非当前发布版，因为如果是最新版，容易出现一些奇妙的 bug。全部默认下一步进行安装。然后Windows 用户打开命令提示符，即按住键盘 Win+R，输入cmd然后回车，弹出黑色代码窗口。</p><blockquote><p>MacOS 用户打开终端。（这个不会就请百度吧，我没用过）</p><p>Linux 用户右上角关闭本标签页。</p></blockquote><p>后续如提到输入命令，均默认指打开终端进行输入。</p><p>输入<code>node --version</code>回车，如果得到的版本号与你方才安装的一致，那么 Node.js 就已经成功安装。</p><blockquote><p>Node.js 安装成功时也默认安装了 npm，在此后将会用到。npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。</p></blockquote><p>对了，国内使用 npm 可能很慢，你可以“科学上网”，或者考虑切换为 taobao 镜像源，即手动输入以下内容后按回车（也可以Ctrl+C和Ctrl+V复制以下代码按回车）：</p><pre class="line-numbers language-none"><code class="language-none">npm config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="五、安装Hexo"><a href="#五、安装Hexo" class="headerlink" title="五、安装Hexo"></a>五、安装Hexo</h2><p>Hexo 是一个快速、简洁而强大的博客框架，基于 Node.js，同样托管于 GitHub 之上。生态中拥有众多插件主题。你可以基于它快速生成一些静态页面。你可以使用别人的各种主题与插件，也可以自己定制开发想要的功能。</p><blockquote><p>为什么不是…?</p><p>其他常用的博客框架还有 WordPress，Typecho，Ghost 等，但这些往往都需要购置自己的服务器，而无法静态化地部署到 GitHub Pages 上。（当然，相应的功能和灵活性也大大提升。）静态化站点还有一个优势就是访问速度往往更快。</p><p>静态网站生成器还有 Vuepress，Gatsby 等。但这些多是为了写文档而量身定制的，你也可以使用它们，但是相较 Hexo 的博客定位，它们关于博客的插件和主题以及解决办法会少得多。</p><p>Hexo 提供的功能与 Hugo 几乎都有，（生成大量文件时，甚至比 Hexo 更快）不过它是基于 GO 语言。日后你想对自己的网站进行自定义，即便是 Hugo，你编写前端的交互仍旧需要使用 JavaScript，所以选择基于 JavaScript 的 Hexo 可以降低学习成本。（你若对 GO 有兴趣，仍然可以尝试使用 Hugo，但本教程将不会针对 Hugo 进行展开。）</p><p>所以对于新手来说，使用 Hexo 作为起始点，不失为一个好选择。（当然如果你有钱租服务器，并希望快速上手的话，就可以考虑考虑 WordPress 或者 Typecho）</p></blockquote><p>如何安装Hexo呢?</p><p>在cmd终端窗口中输入以下命令后回车：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后等待一会进度条走完，没报错就代表安装成功。</p><p>进度条卡住不动可能还是国内网络问题，“科学上网”哦，咳咳….</p><blockquote><p>如果安装失败，可能是没有权限，可以尝试头部加上 sudo 重新执行，即输入：</p><p><code>sudo npm install hexo-cli -g</code>然后回车 </p></blockquote><p>上面命令中，</p><p>install 自然是安装。</p><p>hexo-cli 则是 hexo 的终端工具，可以帮助你生成一些模版文件，之后再用到。</p><p>-g 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。</p><h2 id="六、初始化-Hexo-工程"><a href="#六、初始化-Hexo-工程" class="headerlink" title="六、初始化 Hexo 工程"></a>六、初始化 <em>Hexo</em> 工程</h2><p>注意：接下来应该是你自己的自定义的目录，请不要完全复制粘贴我的！</p><p>比如说我是Windows用户，想把我的网站代码储存在</p><p>电脑 E 盘的 *<strong>BarryFlynn\Github*</strong> 文件夹下</p><p>那么我要先在E盘建立相应的文件夹，然后再继续操作。</p><p>由于cmd终端最开始默认在C盘操作，我得先切换到E盘，那么我要输入 <em><strong>E:</strong></em>  然后回车,即：</p><pre class="line-numbers language-none"><code class="language-none">Microsoft Windows [版本 10.0.19042.1165](c) Microsoft Corporation。保留所有权利。C:\Users\10272&gt;E:E:\&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后此时，我要通过 *<strong>cd*</strong>  进入我本地电脑打算存储网站代码的文件夹目录。（或者右键文件夹 Git Bash Here），即 *<strong>BarryFlynn\Github*</strong> 文件夹里</p><blockquote><p><a href="https://baike.baidu.com/item/cd/3516393">cd | DOS 命令</a></p><p><a href="https://baike.baidu.com/item/cd/3516411">cd （LINUXSHELL 命令）</a></p></blockquote><p> 也就是说我需要输入 *<strong>cd BarryFlynn\Github*</strong> 然后回车，我会看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\&gt;cd BarryFlynn\Github\E:\BarryFlynn\Github&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>好了成功进入，接下来输入下方代码，再按回车：</p><pre class="line-numbers language-none"><code class="language-none">hexo init 你的名字.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>hexo</code> ：正是因为我们之前安装了 <code>hexo-cli</code> 这一个包，所以我们可以在终端中使用 <code>hexo</code> 这一命令。</p><p><code>init</code> ：用来初始化博客的模版文件。后面跟的是你要新建的文件夹，最好和你此前新建的仓库名一致，比如我的是：*<strong>Barry-Flynn.github.io*</strong></p></blockquote><p>然后我会看到</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github&gt;hexo init Barry-Flynn.github.ioINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git[32mINFO [39m Install dependenciesadded 242 packages from 207 contributors in 105.871s15 packages are looking for funding  run `npm fund` for detailsINFO  Start blogging with Hexo!E:\BarryFlynn\Github&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面通过 *<strong>cd*</strong>  进入我的博客文件夹，</p><p>即输入 <em>cd Barry-Flynn.github.io</em> 后按回车，我会看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github&gt;cd Barry-Flynn.github.ioE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在我就是处于 E:\BarryFlynn\Github\Barry-Flynn.github.io 文件夹下操作了，</p><p>现在在这个文件夹内默认安装所有 <code>package.json</code> 文件中提到的包，</p><p>即输入  <em><strong>npm install</strong></em>  然后回车，我会看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;npm installnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.2 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})audited 243 packages in 4.956s15 packages are looking for funding  run `npm fund` for detailsfound 0 vulnerabilitiesE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候，我的 Barry-Flynn.github.io 文件夹里面会多出一堆文件，</p><p>文件夹结构应该大致是这样：</p><pre class="line-numbers language-none"><code class="language-none">.├── config.yml├── package.json├── scaffolds├── source|  ├── _drafts|  └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们输入  <em><strong>hexo server</strong></em>  然后回车，会看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;hexo serverINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code> 代表开启本地的 Hexo 服务器，这时你就可以打开浏览器，在地址栏中输入 <code>localhost:4000</code> 就可以看到本地的网页了。</p></blockquote><p><img src="/2022/02/13/hexo-bo-ke-da-jian/HexoPage.png" alt="Hexo主页"></p><p>这个网页就是Hexo为你自动生成的博客页面。</p><p>按  <em>Ctrl+C</em>  中断服务器的运行，</p><p>系统提示  <em><strong>终止批处理操作吗(Y/N)?</strong></em>  输入 <em><strong>Y</strong></em> 然后回车。</p><p>至此，基础的模版页面便已经搭建好了。</p><h2 id="七、生成静态文件"><a href="#七、生成静态文件" class="headerlink" title="七、生成静态文件"></a>七、生成静态文件</h2><p>到现在，我们的工作都是在本地进行，想必你也很想放到线上与小伙伴们分享。这便轮到了 GitHub Pages 的出场，不过 GitHub Pages 只支持纯静态文件。</p><p>所以我们需要使用下面一行命令先来生成站点的静态文件。</p><pre class="line-numbers language-none"><code class="language-none">（如果进行多次生成，为了避免受错误缓存影响，最好使用 hexo clean 先清除一遍。）hexo generate（上方命令也可以缩写为 hexo g）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 输入后回车，我会看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;hexo gINFO  Validating configINFO  Start processingINFO  Files loaded in 209 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2021/index.htmlINFO  Generated: archives/2021/08/index.html(node:20772) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)(node:20772) Warning: Accessing non-existent property 'column' of module exports inside circular dependency(node:20772) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency(node:20772) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency(node:20772) Warning: Accessing non-existent property 'column' of module exports inside circular dependency(node:20772) Warning: Accessing non-existent property 'filename' of module exports inside circular dependencyINFO  Generated: index.htmlINFO  Generated: fancybox/jquery.fancybox.min.cssINFO  Generated: js/script.jsINFO  Generated: 2021/08/25/hello-world/index.htmlINFO  Generated: css/style.cssINFO  Generated: css/fonts/fontawesome-webfont.woff2INFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: fancybox/jquery.fancybox.min.jsINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  Generated: js/jquery-3.4.1.min.jsINFO  Generated: css/images/banner.jpgINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  17 files generated in 1.98 sE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我的文件夹目录下会出现 <em><strong>public</strong></em>  这个文件夹，里面存放的就是我的站点的静态文件。</p><h2 id="八、与远程仓库建立关联"><a href="#八、与远程仓库建立关联" class="headerlink" title="八、与远程仓库建立关联"></a>八、与远程仓库建立关联</h2><p>接下来我们将本地的仓库与此前在 GitHub 上建立的仓库建立关联。</p><p>输入  <em><strong>git init</strong></em>  初始化 Git 仓库，只需要执行一次即可，看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git initInitialized empty Git repository in E:/BarryFlynn/Github/Barry-Flynn.github.io/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在将其部署到 GitHub Pages 上之前，我们最好先建立一个分支。</p><blockquote><p>什么是分支？</p><p>Git 提供了版本管理功能，其中还有一个分支功能，你现在可以简单地将其理解为平行世界。</p></blockquote><p> <em><strong>你的名字.github.io</strong></em> 部署后，GitHub Pages 将默认使用你的 main分支（以前叫 master分支，一个意思，主要分支的意思）作为静态文件部署。所以我们最好新建一个 hexo 分支（命名无所谓）用来存储 Hexo 地源代码，master 分支则用来存储部署后的静态文件。为了方便，不想其他名字了，这个分支我就起名叫 hexo 吧。</p><p>新建该分支的命令语句是  <em><strong>git checkout -b hexo</strong></em>  ，然后回车，可以看到：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git checkout -b hexoSwitched to a new branch 'hexo'E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这时便成功建立了一个 hexo 分支。（此后的工作都将在 hexo 分支下进行）</p><p>你可以通过 <strong><code>git branch -v</code></strong> 来查看当前有哪些分支，使用 <strong><code>git checkout 分支名</code></strong> 来切换到对应的分支。</p><blockquote><p><a href="https://www.yunyoujun.cn/note/git-learn-note/">Git 学习笔记</a></p></blockquote><h2 id="九、部署到-GitHub-Pages"><a href="#九、部署到-GitHub-Pages" class="headerlink" title="九、部署到 GitHub Pages"></a>九、部署到 GitHub Pages</h2><p>为了更方便的部署到 GitHub Pages，Hexo 提供了 <code>hexo-deployer-git</code> 插件。</p><p>老规矩，安装该插件，要输入下面命令，</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回车后可以看到</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;npm install hexo-deployer-gitnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.2 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})+ hexo-deployer-git@3.0.0added 1 package from 1 contributor and audited 244 packages in 8.166s15 packages are looking for funding  run `npm fund` for detailsfound 0 vulnerabilitiesE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面对  <em><strong>Barry-Flynn.github.io</strong></em> 文件夹下的  <em><strong>_config.yml</strong></em>  文件进行配置。</p><p>右键  <em><strong>_config.yml</strong></em>  ，打开方式选VS Code（或者直接用VS Code打开该文件），</p><p>滑到最下面，把关于</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:' '<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>的这段代码补充为</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: https://github.com/Barry-Flynn/Barry-Flynn.github.io #仓库地址  branch: main # 默认使用 master 分支(Github现在改名为main分支)  message: Update Hexo Static Content # 你可以自定义此次部署更新的说明说明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Ctrl+S保存，退出VS Code，部署！</p><p>终端里输入命令  <em><strong>hexo deploy</strong></em>  后（或者缩写为  <em><strong>hexo d</strong></em>  ）回车，我的电脑显示：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;hexo deployINFO  Validating configINFO  Deploying: gitINFO  Setting up Git deployment...Initialized empty Git repository in E:/BarryFlynn/Github/Barry-Flynn.github.io/.deploy_git/.git/Author identity unknown*** Please tell me who you are.Run  git config --global user.email "you@example.com"  git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got '10272@DESKTOP-N3PNS7C.(none)')FATAL {  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (E:\BarryFlynn\Github\Barry-Flynn.github.io\node_modules\hexo-util\lib\spawn.js:51:21)      at ChildProcess.emit (events.js:400:28)      at ChildProcess.cp.emit (E:\BarryFlynn\Github\Barry-Flynn.github.io\node_modules\cross-spawn\lib\enoent.js:34:29)      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) {    code: 128  }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.htmlE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是的，部署出错（FATAL）了,“ Please tell me who you are.”</p><p>原来是创建git文件夹的时候信息不完善导致的，</p><p>它提示我需要运行（Run）下面两行程序，来设置我帐户的默认标识。</p><p>  git config –global user.email “<a href="mailto:you@example.com">you@example.com</a>“</p><p>  git config –global user.name “Your Name”</p><blockquote><p>注意双引号前有空格，邮箱随便填也可以，比如QQ邮箱啥的，</p><p>我用的这个邮箱查找路径是：点击Github主页右上角头像，点击settings，点击Emails，然后就能找到Github的这个邮箱了</p></blockquote><p> 那么我分别输入这两个命令按回车，可见下方代码：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git config --global user.email "Barry-Flynn@users.noreply.github.com"E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git config --global user.name "Barry Flynn"E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再用命令  *<strong>git config -l*</strong>  查看所有的配置信息</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git config -ldiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truehttp.sslbackend=opensslhttp.sslcainfo=E:/Git/mingw64/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=manager-corecredential.https://dev.azure.com.usehttppath=trueinit.defaultbranch=masteruser.email=Barry-Flynn@users.noreply.github.comuser.name=Barry Flynncore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=trueE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看见下面这两条信息，代表信息以及完善上去了</p><p>user.email=<a href="mailto:Barry-Flynn@users.noreply.github.com">Barry-Flynn@users.noreply.github.com</a></p><p>user.name=Barry Flynn</p><p>那我们接着部署吧！</p><p>终端里输入命令  <em><strong>hexo deploy</strong></em>  后（或者缩写为  <em><strong>hexo d</strong></em>  ）回车，我的电脑再次报错：</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;hexo deployINFO  Validating configINFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...INFO  Copying files from extend dirs...warning: LF will be replaced by CRLF in 2021/08/25/hello-world/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in archives/2021/08/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in archives/2021/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in archives/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in css/fonts/fontawesome-webfont.svg.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in css/style.css.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in fancybox/jquery.fancybox.min.js.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in js/jquery-3.4.1.min.js.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in js/script.js.The file will have its original line endings in your working directory[master (root-commit) a9fc5f8] Update Hexo Static Content 17 files changed, 5174 insertions(+) create mode 100644 2021/08/25/hello-world/index.html create mode 100644 archives/2021/08/index.html create mode 100644 archives/2021/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/fonts/fontawesome-webfont.woff2 create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/jquery.fancybox.min.css create mode 100644 fancybox/jquery.fancybox.min.js create mode 100644 index.html create mode 100644 js/jquery-3.4.1.min.js create mode 100644 js/script.jsfatal: unable to access 'https://github.com/Barry-Flynn/Barry-Flynn.github.io/': OpenSSL SSL_read: Connection was reset, errno 10054FATAL {  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (E:\BarryFlynn\Github\Barry-Flynn.github.io\node_modules\hexo-util\lib\spawn.js:51:21)      at ChildProcess.emit (events.js:400:28)      at ChildProcess.cp.emit (E:\BarryFlynn\Github\Barry-Flynn.github.io\node_modules\cross-spawn\lib\enoent.js:34:29)      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) {    code: 128  }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.htmlE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又报错了？我很晕。问了群里大佬，说可能是国内的墙导致的网络问题。好吧，免费的那个什么软件工具果然不太靠谱。解决该问题并重新连接后第三次输入命令  <em><strong>hexo deploy</strong></em>  ，回车</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;hexo deployINFO  Validating configINFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...INFO  Copying files from extend dirs...warning: LF will be replaced by CRLF in 2021/08/25/hello-world/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in archives/2021/08/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in archives/2021/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in archives/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in css/fonts/fontawesome-webfont.svg.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in css/style.css.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in fancybox/jquery.fancybox.min.js.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in js/jquery-3.4.1.min.js.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in js/script.js.The file will have its original line endings in your working directoryOn branch masternothing to commit, working tree cleaninfo: please complete authentication in your browser...Enumerating objects: 31, done.Counting objects: 100% (31/31), done.Delta compression using up to 4 threadsCompressing objects: 100% (25/25), done.Writing objects: 100% (31/31), 882.21 KiB | 4.98 MiB/s, done.Total 31 (delta 3), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (3/3), done.To https://github.com/Barry-Flynn/Barry-Flynn.github.io + 4b62927...a9fc5f8 HEAD -&gt; main (forced update)Branch 'master' set up to track remote branch 'main' from 'https://github.com/Barry-Flynn/Barry-Flynn.github.io'.[32mINFO [39m Deploy done: [35mgit[39mE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功了！Ohhhhhhhhhhh~</p><p>等待完成后，打开网址 <code>https://你的名字.github.io</code> 就能看到你的线上网站了！</p><blockquote><p>使用 https，http 可能无法正常打开。HTTPS 是多了安全加密的 HTTP，Chrome 浏览器已经默认会显示 <code>http</code> 链接为不安全。</p><p>为了安全，建议开启强制 https 跳转。<code>项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Enforce HTTPS</code>。（翻到下面）</p><p>此时，http 网址会自动重定向到 https</p></blockquote><h2 id="十、备份与自动部署"><a href="#十、备份与自动部署" class="headerlink" title="十、备份与自动部署"></a>十、备份与自动部署</h2><p>我们当前只是将生成的静态文件部署到了云端。</p><p>为了以防万一，我们应该将网站的源代码文件也推送到 GitHub 仓库备份。</p><p>输入下方代码按回车，与远程 Git 仓库建立连接，只此一次即可</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin https://github.com/你的用户名/你的名字.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但我一开始因为手抖，没输完就按回车了，如下：</p><p>（注意，这是错误代码！没输完整）</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git remote add origin https://github.com/Barry-Flynn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查了一下，我需要运行输入  <em><strong>git remote rm origin</strong></em>  删除远程地址，</p><p>然后再输入一遍正确的命令与远程 Git 仓库建立连接，之后就行了：</p><p>（你们不用执行这一步哦，我是因为输错地址导致绑定错了）</p><pre class="line-numbers language-none"><code class="language-none">E:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git remote rm originE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;git remote add origin https://github.com/Barry-Flynn/Barry-Flynn.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来准备提交，这三句命令将是你以后每次备份所需要输入。</p><p>（括号内为注释，不用输入哈！）</p><pre class="line-numbers language-none"><code class="language-none">（添加到缓存区）git add -A（这次做了什么更改，简单描述下即可）git commit -m（第一次提交时，你可能需先运行下面命令设置一下默认提交分支）（git push --set-upstream origin hexo）（推送至远程仓库）git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>之后写文章可以在该项目下写，与之前一样，只不过这里同时管理了两个分支。</p><p>master -负责展示静态网页</p><p>hexo -备份本地hexo文件</p><p>master分支更新</p></blockquote><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>hexo分支更新</p></blockquote><pre class="line-numbers language-none"><code class="language-none">git add . #添加所有文件到暂存区git commit -m "新增博客文章"  #提交git push origin hexo #推送hexo分支到Github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="十一、开始写作"><a href="#十一、开始写作" class="headerlink" title="十一、开始写作"></a>十一、开始写作</h2><p>在上一篇文章中提到，初始化hexo博客后我们获得了它自动为我们生成的博客页面，同时还给我们生成了一个标题为“Hello World”的帖子。那么我们以后如何写新帖子发布到我们的博客网站呢？</p><p>打开“命令提示符窗口”进行操作，即之前用到的cmd窗口。</p><blockquote><p>Windows用户打开方式是按住Win+R，再输入cmd然后回车即可。</p></blockquote><p> 打开后我的电脑是显示如下的：</p><pre class="line-numbers language-none"><code class="language-none">Microsoft Windows [版本 10.0.19042.1165](c) Microsoft Corporation。保留所有权利。C:\Users\10272&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和第二篇文章第六步的操作相同，</p><p>由于窗口默认是在C盘操作，我们需要进入到本地电脑之前存储网站代码的“文件夹目录”，对于我来说，由于我存储网站代码的“Barry-Flynn.github.io”文件夹是放在 E盘 的 BarryFlynn\Github\ 文件夹里的，所以我需要先进入 E盘 ，然后回车，显示如下：</p><pre class="line-numbers language-none"><code class="language-none">Microsoft Windows [版本 10.0.19042.1165](c) Microsoft Corporation。保留所有权利。C:\Users\10272&gt;e:E:\&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再通过cd命令进入 BarryFlynn\Github\Barry-Flynn.github.io” 文件夹：</p><p>（这一步请根据你自己之前存放的地址，不要照抄我的哈）</p><pre class="line-numbers language-none"><code class="language-none">Microsoft Windows [版本 10.0.19042.1165](c) Microsoft Corporation。保留所有权利。C:\Users\10272&gt;e:E:\&gt;cd barryflynn\github\barry-flynn.github.ioE:\BarryFlynn\Github\Barry-Flynn.github.io&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（题外话：我通过上面这行命令亲自实践发现，虽然我的文件夹的命名同时包含大小写，但我全输入小写也是可以进入的）</p><p>好了，现在可以开始通过命令开始第一次写作了。</p><h3 id="1-创建新帖子"><a href="#1-创建新帖子" class="headerlink" title="1.创建新帖子"></a>1.创建新帖子</h3><p>输入以下命令，并回车：</p><p>（注意双引号是英文输入法下的！双引号内文字即为你要新建的文章帖子的标题）</p><pre class="line-numbers language-none"><code class="language-none">hexo new "我的第一篇博客文章"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> （或缩写成：hexo n “我的第一篇博客文章”）</p><p>回车后不一会儿，它提示我 Barry-Flynn.github.io\source_posts\我的第一篇博客文章.md 文件已经建好了。你会发现该文件后缀名是“.md”，没错，hexo默认我们用Markdown 格式书写文章。</p><blockquote><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 hexo-renderer-marked 和 hexo-renderer-ejs，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 hexo-renderer-pug，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 md 改成 ejs，Hexo 就会使用 hexo-renderer-ejs 渲染这个文件，其他格式同理。</p></blockquote><p>现在，我之前让大家下载的VSCode编辑器这时候就派上用场了，当然，如果你对Markdown非常熟悉也有自己用的顺手的编辑器的话，当然可以根据你自己的习惯使用别的编辑器进行写作，但本文章仅使用VSCode进行演示。</p><h3 id="2-编写文章内容"><a href="#2-编写文章内容" class="headerlink" title="2.编写文章内容"></a>2.编写文章内容</h3><p>双击打开VSCode，</p><p>点击左上角“文件”，点击“选择文件”，</p><p>找到刚刚新建的“我的第一篇博客文章.md ” 并打开，</p><p>现在可以开始你的创作之旅了。</p><blockquote><p>如果不会用Markdown语法书写文章的话可以在其他地方学习一下，</p><p>或进入官网进行学习：</p><p>Markdown 中文文档 <a href="https://markdown-zh.readthedocs.io/en/latest/">https://markdown-zh.readthedocs.io/en/latest/</a></p></blockquote><p>这里插个话：理论上，vscode 在没有安装任何插件的情况下是可以直接编写markdown文档的，书写过程中点击vscode右上角的其中一个小按钮可以在右侧实时预览效果。</p><p><img src="/2022/02/13/hexo-bo-ke-da-jian/vscode.png" alt="vscode预览"></p><p>但是为了能够得到一些更加丰富的功能和有好多体验，可以通过增添新的插件对其功能进行完善。</p><blockquote><p>比如 Markdown Preview Enhanced 就是一个很好用的完善预览功能的插件，可以更加形象的展示所编写的pdf格式的文档样式。在插件库中搜索markdown即可找到该插件，然后点击安装后重新加载。下面是 Markdown Preview Enhanced 的官方网站：</p><p><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/">https://shd101wyy.github.io/markdown-preview-enhanced/#/</a></p></blockquote><p> 写完后Ctrl+S保存你的文章（或点击vscode左上角“文件”，然后“保存”），关闭vscode。</p><h2 id="十二、更新main分支"><a href="#十二、更新main分支" class="headerlink" title="十二、更新main分支"></a>十二、更新main分支</h2><h3 id="1-清除缓存（可跳过）"><a href="#1-清除缓存（可跳过）" class="headerlink" title="1.清除缓存（可跳过）"></a>1.清除缓存（可跳过）</h3><pre class="line-numbers language-none"><code class="language-none">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令用于清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现你对站点的更改无论如何也不生效，可能需要运行该命令。如果进行了多次生成，为了避免受错误缓存影响，最好使用 hexo clean 先清除一遍。也就是说，网站显示异常时可以执行这条命令试试。</p><h3 id="2-生成静态文件"><a href="#2-生成静态文件" class="headerlink" title="2.生成静态文件"></a>2.生成静态文件</h3><p>输入以下命令，并回车：</p><pre class="line-numbers language-none"><code class="language-none">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（或缩写成：hexo g ）</p><p>此命令使刚刚完成写作的文章生成网站静态文件到默认设置的 public 文件夹。</p><h3 id="3-启动本地服务器（可跳过）"><a href="#3-启动本地服务器（可跳过）" class="headerlink" title="3.启动本地服务器（可跳过）"></a>3.启动本地服务器（可跳过）</h3><p>此步骤用于发布前的本地预览</p><pre class="line-numbers language-none"><code class="language-none">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（或缩写成：hexo s ） </p><p>默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p><p>浏览器输入该网址就能看本地生成的博客了，但也仅仅在本地，GitHub上没有。</p><p>在cmd窗口按  Ctrl+C  中断服务器的运行，</p><p>系统提示  终止批处理操作吗(Y/N)?  输入 Y 然后回车。</p><h3 id="4-一键部署"><a href="#4-一键部署" class="headerlink" title="4.一键部署"></a>4.一键部署</h3><p>输入以下命令，并回车：</p><pre class="line-numbers language-none"><code class="language-none">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（或缩写成：hexo d ）</p><p>此命令使刚刚完成写作的文章自动生成网站静态文件，并部署到设定的仓库。</p><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数。在我这个系列文章的第二篇第九步，我已经带大家修改过了，跟我一路走下来的朋友们不用管了，还没设置过 _config.yml 参数的新来的朋友麻烦去看一下本系列我的上篇文章哈。</p><p>只需等待一会，就可以打开你的博客地址看到新文章发布成功啦。</p><blockquote><p>这一切是如何发生的？</p><p>当执行 hexo deploy 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。</p></blockquote><h2 id="十三、更新备份hexo分支"><a href="#十三、更新备份hexo分支" class="headerlink" title="十三、更新备份hexo分支"></a>十三、更新备份hexo分支</h2><p>根据我上一篇文章中对 _config.yml 文件参数的修改，上边这个部署的命令默认是对我GitHub上的主分支（也可以叫main或者master分支）进行部署更新，上篇文章说过了，我同时管理了两个分支，分别存放不同内容：</p><blockquote><p>main -负责展示静态网页</p><p>hexo -备份本地hexo文件</p></blockquote><p>分别运行下面三行命令，进行hexo分支更新（后面括号内为注释，无需输入）</p><pre class="line-numbers language-none"><code class="language-none">git add -A （此命令用来添加所有文件到暂存区）git commit -m "新增博客文章"  （此命令用来提交，双引号内可自定义内容，双引号前有空格）git push origin hexo （此命令用来推送hexo分支到Github）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一行命令其实有三种写法：（注意第三种写法后面有个点）</p><blockquote><p>git add -A  </p><p>提交所有变化（就是git add –all的缩写）</p><p>git add -u  </p><p>提交被修改 (modified) 和被删除 (deleted) 的文件，不包括新文件 (new)</p><p>git add .  </p><p>提交新文件 (new) 和被修改 (modified) 文件，不包括被删除 (deleted) 文件</p></blockquote><blockquote><p> git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p><p>git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</p><p>git add -A ：是上面两个功能的合集（git add –all的缩写）</p><p>————————————————</p><p>此注释摘自：<a href="https://blog.csdn.net/caseywei/article/details/90945295">https://blog.csdn.net/caseywei/article/details/90945295</a></p></blockquote><p>第二行的“-m”应该是“message”的缩写，双引号内是自定义提交信息</p><blockquote><p>在上一篇文章中我们对 _config.yml  的message参数设置的就是这个，你可以自定义此次部署更新的说明，比如：“x年x月x日的备份”、“第x次备份”等等都可以</p></blockquote><p>关于第二行命令提交时的自定义信息，具体的用处看下图，其实相当于是个注释。</p><p><img src="/2022/02/13/hexo-bo-ke-da-jian/message.png" alt="Github注释"></p><p>三步全部执行完后打开GitHub相应库的hexo分支里就可以看到跟刚才不一样的地方了</p><p><img src="/2022/02/13/hexo-bo-ke-da-jian/push.png" alt="提交自定义信息后的GitHub.png"></p><p>意味着hexo源文件更新成功，推送到了 GitHub 仓库进行了备份。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每次更新博客时都可以走以下三个大步</p><h3 id="一、写作部分"><a href="#一、写作部分" class="headerlink" title="一、写作部分"></a>一、写作部分</h3><p>1、打开cmd进入存放博客代码文件夹</p><p>2、创建文章：</p><pre class="line-numbers language-none"><code class="language-none">hexo n "文章标题"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、使用vscode打开新建的.md文件编写内容</p><h3 id="二、对main分支进行部署更新："><a href="#二、对main分支进行部署更新：" class="headerlink" title="二、对main分支进行部署更新："></a>二、对main分支进行部署更新：</h3><pre class="line-numbers language-none"><code class="language-none">hexo clean （清理缓存，可选用）hexo g （生成资源文件）hexo d （部署到服务器）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三、对hexo分支进行部署更新："><a href="#三、对hexo分支进行部署更新：" class="headerlink" title="三、对hexo分支进行部署更新："></a>三、对hexo分支进行部署更新：</h3><pre class="line-numbers language-none"><code class="language-none">git add -A （添加所有文件到暂存区）git commit -m "自定义信息" （提交此次更新的信息）git push origin hexo （推送hexo分支到Github）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="四、打开你的博客网址查看显示效果"><a href="#四、打开你的博客网址查看显示效果" class="headerlink" title="四、打开你的博客网址查看显示效果"></a>四、打开你的博客网址查看显示效果</h3>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
